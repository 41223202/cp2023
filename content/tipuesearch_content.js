var tipuesearch = {"pages": [{'title': 'About', 'text': ' https://github.com/mdecycu/cmsite  \n', 'tags': '', 'url': 'About.html'}, {'title': 'w5', 'text': '// 包含標準輸出入程式庫的標頭文件\n// https://blog.csdn.net/weixin_38468077/article/details/101069365\n// http://www.gnuplot.info/demo/\n// https://github.com/sysprog21/rv32emu\n// https://github.com/sysprog21/semu \n// https://docs.google.com/presentation/d/14N0cWG2SnBSqhc2cLF0_2VerB9FF8JN3\n// https://cs61c.org/fa23/\n// https://greenteapress.com/wp/think-python-2e/\n// https://github.com/ecalvadi/c99-examples\n// https://github.com/gouravthakur39/beginners-C-program-examples\n// https://github.com/ergenekonyigit/Numerical-Analysis-Examples\n// https://www.che.ncku.edu.tw/facultyweb/changct/html/teaching/CPPandMATLAB/Past/pdf%20Files/Chap02-Ling.pdf\n// https://gteceducation.com.sg/Brochures/PROGRAMMING/C%20PROGRAMMING%20FULL.pdf\n// https://jsommers.github.io/cbook/cbook.pdf\n// https://jsommers.github.io/cbook/index.html\n// http://student.itee.uq.edu.au/courses/csse2310/CProgrammingNotes.pdf\n// http://cslibrary.stanford.edu/101/EssentialC.pdf\n// https://publications.gbdirect.co.uk/c_book/\n// https://www.fossil-scm.org/fossil-book/doc/2ndEdition/fossilbook.pdf\n// ***** execute on replit \n// cd downloads\n// cc gnuplot_ex1.c -o gnuplot_ex1\n// ./gnuplot_ex1\n#include <stdio.h>\n\n// 主函式\nint main() {\n    // Start a Gnuplot process using popen\n    FILE *gnuplotPipe = popen("gnuplot -persistent", "w");\n    if (!gnuplotPipe) {\n        fprintf(stderr, "Failed to start Gnuplot.\\n");\n        return 1;\n    }\n\n    // Use Gnuplot plotting commands, specify font and output as PNG\n    fprintf(gnuplotPipe, "set terminal png font \'default,10\' size 800,400\\n");\n    fprintf(gnuplotPipe, "set output \'./../images/gnuplot_ex1.png\'\\n");\n    fprintf(gnuplotPipe, "plot sin(x)");\n    // Close popen\n    pclose(gnuplotPipe);\n\n    return 0;\n} \n clear \n cd downloads \n cc gnuplot_ex1.c \n ./a.out \n \n', 'tags': '', 'url': 'w5.html'}, {'title': 'w6', 'text': '// https://en.wikipedia.org/wiki/Flag_of_the_Republic_of_China\n// cc roc_flag.c -lgd -lm to link with gd and math library\n// https://www.rapidtables.com/web/color/RGB_Color.html\n// 幾何形狀著色與繪圖練習\n// 以下 gd 繪圖程式嘗試畫出 ROC 國旗, 請根據下列程式內容完成後續的國旗繪圖\n#include <stdio.h>\n#include <gd.h>\n#include <math.h>\n\nvoid draw_roc_flag(gdImagePtr img);\nvoid draw_white_sun(gdImagePtr img, int center_x, int center_y, int sun_radius, int white, int red, int blue);\n\nint main() {\n    // width 3: height 2\n    int width = 1200;\n    int height = (int)(width*2.0 / 3.0);\n\n    gdImagePtr img = gdImageCreateTrueColor(width, height);\n    gdImageAlphaBlending(img, 0);\n\n    draw_roc_flag(img);\n\n    FILE *outputFile = fopen("./roc_flag.png", "wb");\n    if (outputFile == NULL) {\n        fprintf(stderr, "Error opening the output file.\\n");\n        return 1;\n    }\n    gdImagePngEx(img, outputFile, 9);\n    fclose(outputFile);\n    gdImageDestroy(img);\n    return 0;\n}\n\nvoid draw_roc_flag(gdImagePtr img) {\n    int width = gdImageSX(img);\n    int height = gdImageSY(img);\n    int red, white, blue;\n    int center_x = (int)(width/4);\n    int center_y = (int)(height/4);\n    int sun_radius = (int)(width/8);\n\n    // Colors for the flag\n    red = gdImageColorAllocate(img, 242, 0, 0); // Red color\n    white = gdImageColorAllocate(img, 255, 255, 255); // White stripes\n    blue = gdImageColorAllocate(img, 0, 41, 204); // Blue\n\n    // 繪製紅色矩形區域\n    gdImageFilledRectangle(img, 0, 0, width, height, red);\n\n    // 繪製藍色矩形區域\n    gdImageFilledRectangle(img, 0, 0, (int)(width/2.0), (int)(height/2.0), blue);\n\n    // 繪製太陽\n    draw_white_sun(img, center_x, center_y, sun_radius, white, red, blue);\n}\nvoid draw_white_sun(gdImagePtr img, int center_x, int center_y, int sun_radius, int white, int red, int blue) {\n    float angle = 0;\n    int numRays = 12; // 光芒的數量\n\n    gdPoint points[3]; // 三個頂點的陣列\n\n    for (int i = 0; i < numRays; i++) {\n        angle = i * (2 * M_PI / numRays);\n        float x1 = center_x + cos(angle) * sun_radius;\n        float y1 = center_y + sin(angle) * sun_radius;\n\n        // 調整兩個底邊頂點的位置\n      float x2 = center_x + cos(angle + 0.35) * (sun_radius * 0.5);\n      float y2 = center_y + sin(angle + 0.35) * (sun_radius * 0.5);\n      float x3 = center_x + cos(angle - 0.35) * (sun_radius * 0.5);\n      float y3 = center_y + sin(angle - 0.35) * (sun_radius * 0.5);\n\n        // 設定多邊形的三個頂點\n        points[0].x = (int)x1;\n        points[0].y = (int)y1;\n        points[1].x = (int)x2;\n        points[1].y = (int)y2;\n        points[2].x = (int)x3;\n        points[2].y = (int)y3;\n\n        gdImageFilledPolygon(img, points, 3, white);\n    }\n  //外圈\n  gdImageFilledEllipse(img, center_x, center_y, sun_radius * 1.2, sun_radius * 1.2, blue);\n\n    // 繪製太陽內部\n    gdImageFilledEllipse(img, center_x, center_y, sun_radius * 1.1, sun_radius * 1.1, white);\n} \n clear \n cd downloads \n cc gd_roc_flag.c -lgd -lm \n ./a.out \n \n // https://en.wikipedia.org/wiki/Flag_of_the_United_States\n// https://www.britannica.com/topic/flag-of-the-United-States-of-America\n// 以下為幾乎要繪製完成的美國國旗, 請修改下列原始碼, 令其繪出正確的美國國旗\n#include <stdio.h>\n#include <gd.h>\n#include <math.h>\n\nvoid draw_usa_flag(gdImagePtr img);\nvoid draw_star(gdImagePtr img, int x, int y, int size, int color, double rotation_angle);\n\nint main() {\n    int width = 800;\n    int height = (int)(width / 1.9);\n\n    gdImagePtr img = gdImageCreateTrueColor(width, height);\n    gdImageAlphaBlending(img, 0);\n\n    draw_usa_flag(img);\n\n    FILE *outputFile = fopen("./../images/usa_flag.png", "wb");\n    if (outputFile == NULL) {\n        fprintf(stderr, "打开输出文件时出错。\\n");\n        return 1;\n    }\n\n    gdImagePngEx(img, outputFile, 9);\n    fclose(outputFile);\n    gdImageDestroy(img);\n\n    return 0;\n}\n\nvoid draw_usa_flag(gdImagePtr img) {\n    int width = gdImageSX(img);\n    int height = gdImageSY(img);\n    int red, white, blue;\n    // 国旗颜色\n    red = gdImageColorAllocate(img, 178, 34, 52); // 红色条纹\n    white = gdImageColorAllocate(img, 255, 255, 255); // 白色条纹\n    blue = gdImageColorAllocate(img, 60, 59, 110); // 蓝色矩形\n\n    int stripe_height = height / 13;\n    int stripe_width = width;\n    int star_size = (int)(0.0308 * height); // 星星大小\n\n    for (int y = 0; y < height; y += stripe_height) {\n        if (y / stripe_height % 2 == 0) {\n            gdImageFilledRectangle(img, 0, y, stripe_width, y + stripe_height, red);\n        } else {\n            gdImageFilledRectangle(img, 0, y, stripe_width, y + stripe_height, white);\n        }\n    }\n\n    gdImageFilledRectangle(img, 0, 0, width * 2 / 5, stripe_height * 7, blue);\n\n    int star_spacing_x = (int)(0.129 * height); // 横向星星之间的间距\n    int star_spacing_y = (int)(0.054 * height); // 纵向星星之间的间距\n    int star_start_x = (int)(0.125 * height); // 星星的起始X位置\n    int star_start_y = (int)(0.0485 * height); // 星星的起始Y位置\n\n    for (int row = 0; row < 9; row++) {\n        int starsPerRow = (row % 2 == 0) ? 6 : 5;\n\n        // 计算2、4、6和8排星星的偏移量\n        int offset_x = (row % 2 == 0) ? star_spacing_x / -2 : 0;\n\n        for (int star = 0; star < starsPerRow; star++) {\n            int x = star_start_x + star * star_spacing_x + offset_x;\n\n            // 旋转角度（以弧度为单位）\n            double rotation_angle = M_PI / 5; // 忘記多少度的旋转\n\n            int y = star_start_y + row * star_spacing_y;\n            draw_star(img, x, y, star_size, white, rotation_angle);\n        }\n    }\n}\n\nvoid draw_star(gdImagePtr img, int x, int y, int size, int color, double rotation_angle) {\n    gdPoint points[10];\n\n    for (int i = 0; i < 10; i++) {\n        double angle = M_PI / 2 + i * 2 * M_PI / 10 + rotation_angle;\n        int radius = (i % 2 == 0) ? size : size / 2;\n        points[i].x = x + radius * cos(angle);\n        points[i].y = y + radius * sin(angle);\n    }\n\n    // 用指定的颜色填充星星\n    gdImageFilledPolygon(img, points, 10, color);\n} \n clear \n cd downloads \n cc gd_usa_flag.c -lgd -lm \n ./a.out \n \n \n', 'tags': '', 'url': 'w6.html'}, {'title': 'w7', 'text': '\n #include <stdio.h>\n#include <gd.h>\n#include <math.h>\n\nvoid draw_chinese_flag(gdImagePtr img);\n\nint main() {\n    int width = 300; // 國旗寬度\n    int height = 200; // 國旗高度\n\n    gdImagePtr im = gdImageCreateTrueColor(width, height);\n    gdImageAlphaBlending(im, 0);\n\n    draw_chinese_flag(im);\n\n    FILE *outputFile = fopen("./../images/proc_flag.png", "wb");\n    if (outputFile == NULL) {\n        fprintf(stderr, "打开输出文件时出错。\\n");\n        return 1;\n    }\n\n    gdImagePngEx(im, outputFile, 9);\n    fclose(outputFile);\n    gdImageDestroy(im);\n\n    return 0;\n}\n\n// 声明 draw_star 函数\nvoid draw_star(gdImagePtr img, int x, int y, int size, int color, double rotation_angle);\n\nvoid draw_chinese_flag(gdImagePtr img) {\n    int width = gdImageSX(img);\n    int height = gdImageSY(img);\n    int red, yellow;\n\n    // 國旗顏色\n    red = gdImageColorAllocate(img, 255, 0, 0); // 紅色背景\n    yellow = gdImageColorAllocate(img, 255, 255, 0); // 黃色星星\n\n    // 畫紅色背景\n    gdImageFilledRectangle(img, 0, 0, width, height, red);\n\n    // 設置星星的大小和位置\n    int star_size = (int)(0.28 * height);\n    int star_x = (int)(0.165 * width);\n    int star_y = (int)(0.265 * height);\n\n    // 畫大星星\n    draw_star(img, star_x, star_y, star_size, yellow, 11.0);\n\n    // 繪製小星星，位置根據實際國旗比例計算\n    double radius = 0.15 * height;\n    double angle = 360 / 7 * M_PI / 179.0;\n    double rotation = -M_PI / 7.5;\n    int cx = (int)(0.32 * width);\n    int cy = (int)(0.27 * height);\n\n    for (int i = -1; i < 3; i++) {\n        int x = (int)(cx + radius * cos(i * angle + rotation));\n        int y = (int)(cy + radius * sin(i * angle + rotation));\n        draw_star(img, x, y, 19, yellow, M_PI / 5.0);\n    }\n}\n\nvoid draw_star(gdImagePtr img, int x, int y, int size, int color, double rotation_angle) {\n    gdPoint points[10];\n\n    // 计算星形的五个外点和五个内点\n    double outer_radius = size / 2;\n    double inner_radius = size / 6;\n    double angle = M_PI / 5.0;\n\n    for (int i = 0; i < 10; i++) {\n        double radius = (i % 2 == 0) ? outer_radius : inner_radius;\n        double theta = rotation_angle + i * angle;\n        points[i].x = x + radius * cos(theta);\n        points[i].y = y + radius * sin(theta);\n    }\n\n    // 使用 gdImageFilledPolygon 绘制星形\n    gdImageFilledPolygon(img, points, 10, color);\n} \n \n \n \n #include <stdio.h>\n#include <gd.h>\n#include <math.h>\n\nvoid draw_uk_flag(gdImagePtr img);\nvoid fillTriangle(gdImagePtr img, int x1, int y1, int x2, int y2, int x3, int y3, int color);\n\nint main() {\n    // 设置国旗的宽和高\n    int width = 1200;\n    int height = width / 2;\n\n    // 创建图像\n    gdImagePtr img = gdImageCreateTrueColor(width, height);\n    gdImageAlphaBlending(img, 0);\n\n    // 绘制英国国旗\n    draw_uk_flag(img);\n\n    // 将图像保存到文件\n    FILE *outputFile = fopen("./../images/uk_flag.png", "wb");\n    if (outputFile == NULL) {\n        fprintf(stderr, "打开输出文件时发生错误。\\n");\n        return 1;\n    }\n    gdImagePngEx(img, outputFile, 9);\n    fclose(outputFile);\n    gdImageDestroy(img);\n    return 0;\n}\n\n\n\nvoid draw_uk_flag(gdImagePtr img) {\n    int width = gdImageSX(img);\n    int height = gdImageSY(img);\n\n    int red, white, blue;\n    red = gdImageColorAllocate(img, 204, 0, 0);       // 红色\n    white = gdImageColorAllocate(img, 255, 255, 255); // 白色\n    blue = gdImageColorAllocate(img, 0, 0, 153);      // 蓝色\n\n    gdImageFilledRectangle(img, 0, 0, width, height, blue);\n\n\n  int x1, y1, x2, y2, x3, y3;\n  {\n    int line_thickness = 100;\n    gdImageSetThickness(img, line_thickness);\n\n    int x1, y1, x2, y2, x3, y3;\n\n    // 绘制白色斜线\n    x1 = 0;\n    y1 = 600;\n    x2 = 1200;\n    y2 = 0;\n    gdImageLine(img, x1, y1, x2, y2, white);\n\n    x1 = 0;\n    y1 = 0;\n    x2 = 1200;\n    y2 = 600;\n    gdImageLine(img, x1, y1, x2, y2, white);\n}\n  {\n    int line_thickness = 33;\n    gdImageSetThickness(img, line_thickness);\n\n\n    // 绘制红色斜线\n    x1 = 566;\n    y1 = 300;\n    x2 = 1166;\n    y2 = 0;\n    gdImageLine(img, x1, y1, x2, y2, red);\n\n    x1 = 1233;\n    y1 = 600;\n    x2 = 633;\n    y2 = 300;\n    gdImageLine(img, x1, y1, x2, y2, red);\n\n    x1 = 566;\n    y1 = 300;\n    x2 = -33;\n    y2 = 0;\n    gdImageLine(img, x1, y1, x2, y2, red);\n\n    x1 = 600;\n    y1 = 316.5;\n    x2 = 0;\n    y2 = 616.5;\n    gdImageLine(img, x1, y1, x2, y2, red);\n  }\n  {\n  int line_thickness = 33;\n  gdImageSetThickness(img, line_thickness);\n\n  int x1, y1, x2, y2, x3, y3;\n\n  // 绘制  斜线\n  x1 = 0;\n  y1 = 600;\n  x2 = 1200;\n  y2 = 0;\n  gdImageLine(img, x1, y1, x2, y2, red );\n\n\n  x1 = 1200;\n    y1 = 16.5;\n    x2 = 600;\n    y2 = 316.5;\n    gdImageLine(img, x1, y1, x2, y2, white);\n\n\n  x1 = 0;\n    y1 = 583.5;\n    x2 = 600;\n    y2 = 283.5;\n    gdImageLine(img, x1, y1, x2, y2, white);\n\n\n  }\n\n    // 绘制白色十字\n    int cross_width = width / 32;\n    int cross_arm_width = width / 32;\n    int center_x = width / 2;\n    int center_y = height / 2;\n\n    gdImageFilledRectangle(img, center_x + 2.7 * cross_width, 0, center_x - 2.7 * cross_width, height, white);\n    gdImageFilledRectangle(img, 0, center_y + 2.7 * cross_arm_width, width, center_y - 2.7 * cross_arm_width, white);\n\n    // 绘制红色十字\n    gdImageFilledRectangle(img, center_x + 1.5 * cross_width, 0, center_x - 1.5 * cross_width, height, red);\n    gdImageFilledRectangle(img, 0, center_y + 1.5 * cross_arm_width, width, center_y - 1.5 * cross_arm_width, red);\n} \n \n \n #include <stdio.h>\n#include <gd.h>\n#include <math.h>\n\nvoid draw_japan_flag(gdImagePtr img);\nvoid draw_white_sun(gdImagePtr img, int center_x, int center_y, int sun_radius, int white, int red );\n\nint main() {\n    // width 3: height 2\n    int width = 1200;\n    int height = 2 * width / 3;\n\n    gdImagePtr img = gdImageCreateTrueColor(width, height);\n    gdImageAlphaBlending(img, 0);\n\n    draw_japan_flag(img);\n\n    FILE *outputFile = fopen("./../images/japan_flag.png", "wb");\n    if (outputFile == NULL) {\n        fprintf(stderr, "Error opening the output file.\\n");\n        return 1;\n    }\n    gdImagePngEx(img, outputFile, 9);\n    fclose(outputFile);\n    gdImageDestroy(img);\n    return 0;\n}\n\nvoid draw_japan_flag(gdImagePtr img) {\n    int width = gdImageSX(img);\n    int height = gdImageSY(img);\n    int red, white ;\n    int center_x =  0.5 * width;\n    int center_y =  0.5 * height;\n    int sun_radius = 145 ;\n\n    // Colors for the flag\n    red = gdImageColorAllocate(img, 242, 0, 0); // Red color\n    white = gdImageColorAllocate(img, 255, 255, 255); // White stripes\n\n\n    // 繪製白色矩形區域\n    gdImageFilledRectangle(img, 0, 0, width, height, white);\n\n\n    // 繪製太陽內部\n    gdImageFilledEllipse(img, center_x, center_y, sun_radius * 3, sun_radius * 3, red);\n} \n \n \n #include <stdio.h>\n#include <gd.h>\n#include <math.h>\n\n#define WIDTH 900\n#define HEIGHT 600\n#define FILENAME "south_korea_flag.png"\n\nint main() {\n    gdImagePtr im;\n    FILE *pngout;\n    int white, black, red, blue;\n\n    im = gdImageCreate(WIDTH, HEIGHT);\n\n    white = gdImageColorAllocate(im, 255, 255, 255);\n    black = gdImageColorAllocate(im, 0, 0, 0);\n    red = gdImageColorAllocate(im, 205, 0, 0);\n    blue = gdImageColorAllocate(im, 0, 56, 168);\n\n    // Background (white)\n    gdImageFilledRectangle(im, 0, 0, WIDTH, HEIGHT , white);\n\n    // Blue Circle (Yin-Yang Symbol)\n    gdImageFilledArc(im, WIDTH / 2, HEIGHT / 2, WIDTH / 3, HEIGHT / 2, 210, 30, red, gdArc);\n\n    // Red Circle (Yin-Yang Symbol)\n    gdImageFilledArc(im, WIDTH / 2, HEIGHT / 2, WIDTH / 3, HEIGHT / 2, 30, 210, blue, gdArc);\n\n  int circleX = 385;    // 圓心的 X 座標\n  int circleY = 262.5;   // 圓心的 Y 座標\n  int circleRadius = 75;     \n\n  // 繪製圓形\n  gdImageFilledEllipse(im, circleX, circleY, circleRadius * 2, circleRadius * 2, red);\n\n  int circleX2 = 515;    // 圓心的 X 座標\n\n int circleY2 = 337.5;\n\n  // 繪製圓形\n  gdImageFilledEllipse(im, circleX2, circleY2, circleRadius * 2, circleRadius * 2, blue);\n\n  {\n\n\n  // 起點和終點位置\n\n  int startX = 340;    \n  // 線的起點 X 座標\n\n  int startY = 90;   \n  // 線的起點 Y 座標\n\n  int endX = 200;     \n  // 線的終點 X 座標\n\n  int endY = 260;     \n  // 線的終點 Y 座標\n\n  int lineWidth = 23;  // 線的寬度\n\n  // 繪製線段\n  gdImageSetThickness(im, lineWidth);\n  gdImageLine(im, startX, startY, endX, endY, black);\n  // 繪製線段\n  gdImageSetThickness(im, lineWidth);\n  gdImageLine(im, startX -35, startY -10, endX -35, endY -10, black);\n\n  // 繪製線段\n  gdImageSetThickness(im, lineWidth);\n  gdImageLine(im, startX -70, startY -20, endX -70, endY -20, black);\n\n  int startX2 = 213;    \n  // 線的起點 X 座標\n\n  int startY2 = 270;   \n  // 線的起點 Y 座標\n\n  int endX2 = 133;     \n  // 線的終點 X 座標\n\n  int endY2 = 210;     \n  // 線的終點 Y 座標\n\n  int lineWidth2 = 25;  // 線的寬度\n\n  // 繪製線段\n  gdImageSetThickness(im, lineWidth);\n  gdImageLine(im, startX2 +3, startY2, endX2 +3, endY2, white);\n\n  gdImageSetThickness(im, lineWidth +10);\ngdImageLine(im, startX2 -17, startY2 +9 , endX2 -17, endY2 +9 , white);\n\n  gdImageSetThickness(im, lineWidth );\ngdImageLine(im, startX2 +115, startY2 -145, endX2 +115, endY2 -145, white);\n\n  gdImageSetThickness(im, lineWidth);\ngdImageLine(im, startX2 +120, startY2 -155, endX2 +120, endY2 -155, white);\n\n  gdImageSetThickness(im, lineWidth +12);\ngdImageLine(im, startX2 +145, startY2 -155, endX2 +145, endY2 -155, white);\n}\n  {\n    // 起點和終點位置\n\n  int startX = 330;    \n  // 線的起點 X 座標\n\n  int startY = 520;   \n  // 線的起點 Y 座標\n\n  int endX = 190;     \n  // 線的終點 X 座標\n\n  int endY = 350;     \n  // 線的終點 Y 座標\n\n  int lineWidth = 23;  // 線的寬度\n\n  // 繪製線段\n  gdImageSetThickness(im, lineWidth);\n  gdImageLine(im, startX, startY, endX, endY, black);\n  // 繪製線段\n  gdImageSetThickness(im, lineWidth);\n  gdImageLine(im, startX -35, startY +10, endX -35, endY +10, black);\n\n  // 繪製線段\n  gdImageSetThickness(im, lineWidth);\n  gdImageLine(im, startX -70, startY +20, endX -70, endY +20, black);\n\n  int startX2 = 213;    \n  // 線的起點 X 座標\n\n  int startY2 = 330;   \n  // 線的起點 Y 座標\n\n  int endX2 = 133;     \n  // 線的終點 X 座標\n\n  int endY2 = 390;     \n  // 線的終點 Y 座標\n\n  int lineWidth2 = 25;  // 線的寬度\n\n  // 繪製線段\n  gdImageSetThickness(im, lineWidth +8);\n  gdImageLine(im, startX2 -11, startY2, endX2 -11, endY2, white);\n\n  gdImageSetThickness(im, lineWidth +10);\ngdImageLine(im, startX2 -30, startY2 -9 , endX2 -30, endY2 -9 , white);\n\n  gdImageSetThickness(im, lineWidth );\ngdImageLine(im, startX2 +100, startY2 +150, endX2 +100, endY2 +150, white);\n\n  gdImageSetThickness(im, lineWidth);\ngdImageLine(im, startX2 +120, startY2 +155, endX2 +120, endY2 +155, white);\n\n  gdImageSetThickness(im, lineWidth +14);\ngdImageLine(im, startX2 +145, startY2 +157, endX2 +145, endY2 +157, white);\n\n    gdImageSetThickness(im, lineWidth -10);\ngdImageLine(im, 232, 426, 206, 448, white);\n\n  }\n\n  {\n    // 起點和終點位置\n\n  int startX = 564;    \n  // 線的起點 X 座標\n\n  int startY = 520;   \n  // 線的起點 Y 座標\n\n  int endX = 704;     \n  // 線的終點 X 座標\n\n  int endY = 350;     \n  // 線的終點 Y 座標\n\n  int lineWidth = 23;  // 線的寬度\n\n  // 繪製線段\n  gdImageSetThickness(im, lineWidth);\n  gdImageLine(im, startX +70, startY +20, endX +70, endY +20, black);\n\n    // 繪製線段\n  gdImageSetThickness(im, lineWidth);\n  gdImageLine(im, startX, startY, endX, endY, black);\n\n    // 繪製線段\n  gdImageSetThickness(im, lineWidth);\n  gdImageLine(im, startX +35, startY +10, endX +35, endY +10, black);\n\ngdImageSetThickness(im, lineWidth -10);\ngdImageLine(im, 624, 400, 734, 490, white);\n\n  int startX2 = 553;    \n  // 線的起點 X 座標\n\n  int startY2 = 330;   \n  // 線的起點 Y 座標\n\n  int endX2 = 633;     \n  // 線的終點 X 座標\n\n  int endY2 = 390;     \n  // 線的終點 Y 座標\n\n  int lineWidth2 = 25;  // 線的寬度\n\n  // 繪製線段\n  gdImageSetThickness(im, lineWidth +8);\n  gdImageLine(im, startX2 +139, startY2, endX2 +139, endY2, white);\n\n  gdImageSetThickness(im, lineWidth +10);\ngdImageLine(im, startX2 +157, startY2 -9 , endX2 +157, endY2 -9 , white);\n\n  gdImageSetThickness(im, lineWidth);\ngdImageLine(im, startX2 +25, startY2 +155, endX2 +25, endY2 +155, white);\n\n  gdImageSetThickness(im, lineWidth +30);\ngdImageLine(im, startX2 -3, startY2 +170, endX2 , endY2 +170, white);\n  }\n  {\n    // 起點和終點位置\n\n  int startX = 330;    \n  // 線的起點 X 座標\n\n  int startY = 520;   \n  // 線的起點 Y 座標\n\n  int endX = 190;     \n  // 線的終點 X 座標\n\n  int endY = 350;     \n  // 線的終點 Y 座標\n\n  int lineWidth = 23;  // 線的寬度\n\n  // 繪製線段\n  gdImageSetThickness(im, lineWidth);\n  gdImageLine(im, startX, startY, endX, endY, black);\n  // 繪製線段\n  gdImageSetThickness(im, lineWidth);\n  gdImageLine(im, startX -35, startY +10, endX -35, endY +10, black);\n\n  // 繪製線段\n  gdImageSetThickness(im, lineWidth);\n  gdImageLine(im, startX -70, startY +20, endX -70, endY +20, black);\n\n  int startX2 = 213;    \n  // 線的起點 X 座標\n\n  int startY2 = 330;   \n  // 線的起點 Y 座標\n\n  int endX2 = 133;     \n  // 線的終點 X 座標\n\n  int endY2 = 390;     \n  // 線的終點 Y 座標\n\n  int lineWidth2 = 25;  // 線的寬度\n\n  // 繪製線段\n  gdImageSetThickness(im, lineWidth +8);\n  gdImageLine(im, startX2 -11, startY2, endX2 -11, endY2, white);\n\n  gdImageSetThickness(im, lineWidth +10);\ngdImageLine(im, startX2 -30, startY2 -9 , endX2 -30, endY2 -9 , white);\n\n  gdImageSetThickness(im, lineWidth );\ngdImageLine(im, startX2 +100, startY2 +150, endX2 +100, endY2 +150, white);\n\n  gdImageSetThickness(im, lineWidth);\ngdImageLine(im, startX2 +120, startY2 +155, endX2 +120, endY2 +155, white);\n\n  gdImageSetThickness(im, lineWidth +14);\ngdImageLine(im, startX2 +145, startY2 +157, endX2 +145, endY2 +157, white);\n\n    gdImageSetThickness(im, lineWidth -10);\ngdImageLine(im, 232, 426, 206, 448, white);\n\n  }\n  {\n    // 起點和終點位置\n\n  int startX = 564;    \n  // 線的起點 X 座標\n\n  int startY = 97;   \n  // 線的起點 Y 座標\n\n  int endX = 704;     \n  // 線的終點 X 座標\n\n  int endY = 267;     \n  // 線的終點 Y 座標\n\n  int lineWidth = 23;  // 線的寬度\n\n  // 繪製線段\n  gdImageSetThickness(im, lineWidth);\n  gdImageLine(im, startX +70, startY -20, endX +70, endY -20, black);\n\n    // 繪製線段\n  gdImageSetThickness(im, lineWidth);\n  gdImageLine(im, startX, startY, endX, endY, black);\n\n    gdImageSetThickness(im, lineWidth -10);\ngdImageLine(im, 624, 212, 734, 118, white);\n\n    // 繪製線段\n  gdImageSetThickness(im, lineWidth);\n  gdImageLine(im, startX +35, startY -10, endX +35, endY -10, black);\n\n  int startX2 = 553;    \n  // 線的起點 X 座標\n\n  int startY2 = 277;   \n  // 線的起點 Y 座標\n\n  int endX2 = 633;     \n  // 線的終點 X 座標\n\n  int endY2 = 217;     \n  // 線的終點 Y 座標\n\n  int lineWidth2 = 25;  // 線的寬度\n\n  // 繪製線段\n  gdImageSetThickness(im, lineWidth +8);\n  gdImageLine(im, startX2 +134, startY2, endX2 +134, endY2, white);\n\n  gdImageSetThickness(im, lineWidth +10);\ngdImageLine(im, startX2 +157, startY2 +9 , endX2 +157, endY2 +9 , white);\n\n  gdImageSetThickness(im, lineWidth);\ngdImageLine(im, startX2 +25, startY2 -155, endX2 +25, endY2 -155, white);\n\n    gdImageSetThickness(im, lineWidth +30);\ngdImageLine(im, startX2 -5, startY2 -155, endX2 -5, endY2 -155, white);\n\n  }\n\n    // Save image\nFILE *outputFile = fopen("./../images/korea_flag.png", "wb");\nif (outputFile == NULL) {\n    fprintf(stderr, "Error opening the output file.\\n");\n    return 1;\n}\n  gdImagePngEx(im, outputFile, 9);\n      fclose(outputFile);\n      gdImageDestroy(im);\n      return 0;\n  } \n \n \n \n', 'tags': '', 'url': 'w7.html'}, {'title': 'w11', 'text': '#include <stdio.h>\n#include <gd.h>\n#include <math.h>\n\nint main() {\n    int width = 800;\n    int height = 600;\n\n    gdImagePtr img = gdImageCreateTrueColor(width, height);\n    gdImageAlphaBlending(img, 0);\n\n    FILE *outputFile = fopen("hellogd.png", "wb");\n    if (outputFile == NULL) {\n\nfprintf(stderr, "Error opening the output file.\\n");\n\nreturn 1;\n    }\n\n    int red = gdImageColorAllocate(img, 255, 0, 0);\n    int blue = gdImageColorAllocate(img, 0, 0, 255);\n    int black = gdImageColorAllocate(img, 0, 0, 0);\n    int white = gdImageColorAllocate(img, 255, 255, 255);\n    // 長方形塗色\n    gdImageFilledRectangle(img, 0, 0, width, height, white);\n    gdImageFilledRectangle(img, 0, 0, (int)width/4, (int)height/4, blue);\n    // 橢圓形塗色\n    gdImageFilledEllipse(img, (int)width*3/4, (int)height/4, (int)width/4, (int)width/4, red);\n    // 橢圓形畫線\n    gdImageEllipse(img, (int)width*3/4, (int)height*3/4, (int)width/4, (int)width/4, red);\n    // 畫直線\n    gdImageLine(img, (int)width/2, (int)height/2, (int)width/2, (int)height/2 + 100, blue);\n\n    // 多邊形畫線\n    gdPoint points[4];\n    points[0].x = (int)width/4;\n    points[0].y = (int)height*3/4;\n    points[1].x = points[0].x + 100;\n    points[1].y = points[0].y;\n    points[2].x = points[1].x;\n    points[2].y = points[1].y + 100;\n    points[3].x = points[2].x - 100;\n    points[3].y = points[2].y;\n    gdImagePolygon(img, points, 4, black);\n\n    // 多邊形塗色\n    gdPoint points2[4];\n    points2[0].x = (int)width/3;\n    points2[0].y = (int)height/2;\n    points2[1].x = points2[0].x + 100;\n    points2[1].y = points2[0].y;\n    points2[2].x = points2[1].x;\n    points2[2].y = points2[1].y + 100;\n    points2[3].x = points2[2].x - 150;\n    points2[3].y = points2[2].y;\n    gdImageFilledPolygon(img, points2, 4, red);\n\n    gdImagePngEx(img, outputFile, 9);\n    fclose(outputFile);\n    gdImageDestroy(img);\n    return 0;\n} \n \n', 'tags': '', 'url': 'w11.html'}, {'title': 'w13', 'text': '// 包含標準輸出入程式庫的標頭文件\n#include <stdio.h>\n\n// 主函式\nint main() {\n    // Open a file to write displacement and velocity data\n    FILE *outputFile = fopen("motion_data.txt", "w");\n    if (!outputFile) {\n        fprintf(stderr, "Failed to create data file.\\n");\n        return 1;\n    }\n\n    // Simulate motion for 10 seconds and calculate displacement and velocity, while writing data to the file\n    double x = 0.2;  // Initial displacement\n    double v = 0.0;  // Initial velocity\n    double dt = 0.01; // Time step\n    double t = 0.0;  // Time\n\n    while (t <= 10.0) {\n        double acceleration = (-10.0 * x - 0.5 * v) / 1.0; // Modified system parameters here\n        v += acceleration * dt;\n        x += v * dt;\n\n        fprintf(outputFile, "%lf %lf %lf\\n", t, x, v);\n\n        t += dt;\n    }\n\n    // Close the data file\n    fclose(outputFile);\n\n    // Start a Gnuplot process using popen\n    FILE *gnuplotPipe = popen("gnuplot -persistent", "w");\n    if (!gnuplotPipe) {\n        fprintf(stderr, "Failed to start Gnuplot.\\n");\n        return 1;\n    }\n\n    // Use Gnuplot plotting commands, specify font and output as PNG\n    fprintf(gnuplotPipe, "set terminal pngcairo enhanced font \'default,10\' size 800,400\\n");\n    fprintf(gnuplotPipe, "set output \'./../images/motion_plot.png\'\\n");\n    fprintf(gnuplotPipe, "set title \'Displacement and Velocity vs. Time\'\\n");\n    fprintf(gnuplotPipe, "set xlabel \'Time (s)\'\\n");\n    fprintf(gnuplotPipe, "set ylabel \'Displacement (m)\'\\n");\n    fprintf(gnuplotPipe, "plot \'motion_data.txt\' using 1:2 with lines lw 2 title \'Displacement\', \\\n                             \'motion_data.txt\' using 1:3 with lines lw 2 title \'Velocity\'\\n");\n\n    // Close the Gnuplot process\n    fprintf(gnuplotPipe, "exit\\n");\n    pclose(gnuplotPipe);\n\n    return 0;\n} \n \n', 'tags': '', 'url': 'w13.html'}, {'title': 'w15', 'text': '// https://en.wikipedia.org/wiki/Flag_of_the_Republic_of_China\n// 內政部國旗參考資料: https://www.moi.gov.tw/cp.aspx?n=10621\n// cc roc_flag_in_gd.c -lgd -lm to link with gd and math library\n// https://www.rapidtables.com/web/color/RGB_Color.html\n// 幾何形狀著色與繪圖練習\n// 以下 gd 繪圖程式嘗試畫出 ROC 國旗, 請根據下列程式內容完成後續的國旗繪圖\n#include <stdio.h>\n#include <gd.h>\n#include <math.h>\n\nvoid draw_roc_flag(gdImagePtr img);\nvoid draw_white_sun(gdImagePtr img, int x, int y, int size, int color);\n\nint main() {\n    // width 3: height 2\n    int width = 1200;\n    // 國旗長寬比為 3:2\n    int height = (int)(width*2.0 / 3.0);\n\n    gdImagePtr img = gdImageCreateTrueColor(width, height);\n    gdImageAlphaBlending(img, 0);\n\n    draw_roc_flag(img);\n\n    FILE *outputFile = fopen("roc_flag_in_gd.png", "wb");\n    if (outputFile == NULL) {\n        fprintf(stderr, "Error opening the output file.\\n");\n        return 1;\n    }\n    gdImagePngEx(img, outputFile, 9);\n    fclose(outputFile);\n    gdImageDestroy(img);\n    return 0;\n}\n\nvoid draw_roc_flag(gdImagePtr img) {\n    int width = gdImageSX(img);\n    int height = gdImageSY(img);\n    int red, white, blue;\n    // 白日位於青天面積正中央, 因此中心點座標為長寬各 1/4 處\n    int center_x = (int)(width/4);\n    int center_y = (int)(height/4);\n    // gdImageFilledEllipse 需以長寬方向的 diameter 作圖\n    // 由於中央白日圓形的半徑為青天寬度的 1/8\n    // 因此中央白日圓形的直徑為青天寬度的 1/4, 也就是國旗寬度的 1/8\n    // 而且白日十二道光芒的外圍圓形其半徑也是國旗寬度的1/8\n    int sun_radius = (int)(width/8);\n    // 中央白日圓形的直徑等於十二道光芒外圍圓形的半徑\n    int white_circle_dia = sun_radius;\n    // 中央藍色圓形半徑為中央白日的 1又 2/15\n    int blue_circle_dia = white_circle_dia +  white_circle_dia*2/15;\n    // 根據 https://www.moi.gov.tw/cp.aspx?n=10621 訂定國旗三種顏色值\n    red = gdImageColorAllocate(img, 255, 0, 0); // 紅色\n    white = gdImageColorAllocate(img, 255, 255, 255); // 白色\n    blue = gdImageColorAllocate(img, 0, 0, 149); // 藍色\n    // 根據畫布大小塗上紅色長方形區域\n    gdImageFilledRectangle(img, 0, 0, width, height, red);\n    // 青天面積為整面國旗的 1/4, 也是採用長方形塗色\n    gdImageFilledRectangle(img, 0, 0, (int)(width/2.0), (int)(height/2.0), blue);\n    // 先設法以填色畫出六個白色堆疊菱形\n    draw_white_sun(img, center_x, center_y, sun_radius, white);\n    // 利用一個藍色大圓與白色小圓畫出藍色環狀\n    gdImageFilledEllipse(img, center_x, center_y, blue_circle_dia, blue_circle_dia, blue);\n    gdImageFilledEllipse(img, center_x, center_y, white_circle_dia, white_circle_dia, white);\n\n}\n\nvoid draw_white_sun(gdImagePtr img, int center_x, int center_y, int sun_radius, int color) {\n    // M_PI 大小定義於 math.h 標頭檔中, 因為三角函數中採用徑度為角度單位\n    // 因此定義將角度轉為徑度的轉換變數為 deg, 角度值乘上 deg 就可轉為徑度\n    float deg = M_PI/180;\n    // 根據十二道光芒的每一尖角的角度為 15 度, 求出其對應直角三角形的另一角度為 75 度\n    // 求出十二道光芒中任一菱形的 small radius, 也就是菱形的另一個對應小圓的半徑大小\n    float sr = sun_radius/tan(75*deg);\n    int ax, ay, bx, by, dx, dy, ex, ey;\n    gdPoint points[4];\n    /* 在塗上十二道光芒中的單一菱形區域之前, 先以座標點畫線測試是否正確\n    ax = center_x;\n    ay = center_y - sun_radius;\n    bx = center_x - sun_radius*tan(15*deg);\n    by = center_y;\n    ex = center_x;\n    ey = center_y + sun_radius;\n    dx = center_x + sun_radius*tan(15*deg);\n    dy = center_y;\n    // AB\n    gdImageLine(img, ax, ay, bx, by, color);\n    // BE\n    gdImageLine(img, bx, by, ex, ey, color);\n    // ED\n    gdImageLine(img, ex, ey, dx, dy, color);\n    // DA\n    gdImageLine(img, dx, dy, ax, ay, color);\n    */\n    ax = center_x;\n    ay = center_y - sun_radius;\n    printf("%d,%d\\n",ax, ay);\n    bx = center_x - sun_radius*tan(15*deg);\n    by = center_y;\n    ex = center_x;\n    ey = center_y + sun_radius;\n    dx = center_x + sun_radius*tan(15*deg);\n    dy = center_y;\n    // 確定單一菱形區域的塗色正確後, 利用迴圈每次轉動 30 度, 總共轉六次即可塗上十二道光芒區域\n    for (int i=1;i<=6;i++){\n    // A\n    points[0].x = ax+sun_radius*sin(30*deg*i);\n    points[0].y = ay+sun_radius-sun_radius*cos(30*deg*i);\n    printf("A coord: (%d,%d)\\n", points[0].x, points[0].y);\n    // B\n    points[1].x = bx+sr-sr*cos(30*deg*i);\n    points[1].y = by-sr*sin(30*deg*i);\n    printf("B coord: (%d,%d)\\n", points[1].x, points[1].y);\n    // E\n    points[2].x = ex-sun_radius*sin(30*deg*i);\n    points[2].y = ey-(sun_radius-sun_radius*cos(30*deg*i));\n    printf("E coord: (%d,%d)\\n", points[2].x, points[2].y);\n    // D\n    points[3].x = dx-(sr-sr*cos(30*deg*i));\n    points[3].y = dy+sr*sin(30*deg*i);\n    printf("D coord: (%d,%d)\\n\\n", points[2].x, points[2].y);\n    // 對菱形區域範圍塗色\n    gdImageFilledPolygon(img, points, 4, color);\n    // 在菱形區域外圍畫線, 明確界定菱形範圍\n    gdImagePolygon(img, points, 4, color);\n    }\n} \n \n #include <stdio.h>\n\n#include <gd.h>\n\n#include <math.h>\n\n\n\nvoid draw_roc_flag(gdImagePtr img);\n\nvoid draw_white_sun(gdImagePtr img, int x, int y, int size, int color);\n\n\n\nint main() {\n\n    // width 3: height 2\n\n    int width = 1200;\n\n    // 國旗長寬比為 3:2\n\n    int height = (int)(width*2.0 / 3.0);\n\n\n\n    gdImagePtr img = gdImageCreateTrueColor(width, height);\n\n    gdImageAlphaBlending(img, 0);\n\n\n\n    draw_roc_flag(img);\n\n\n\n    FILE *outputFile = fopen("roc_flag_in_gd.png", "wb");\n\n    if (outputFile == NULL) {\n\n        fprintf(stderr, "Error opening the output file.\\n");\n\n        return 1;\n\n    }\n\n    gdImagePngEx(img, outputFile, 9);\n\n    fclose(outputFile);\n\n    gdImageDestroy(img);\n\n    return 0;\n\n}\n\n\n\nvoid draw_roc_flag(gdImagePtr img) {\n\n    int width = gdImageSX(img);\n\n    int height = gdImageSY(img);\n\n    int red, white, blue;\n\n    // 白日位於青天面積正中央, 因此中心點座標為長寬各 1/4 處\n\n    int center_x = (int)(width/4);\n\n    int center_y = (int)(height/4);\n\n    // gdImageFilledEllipse 需以長寬方向的 diameter 作圖\n\n    // 由於中央白日圓形的半徑為青天寬度的 1/8\n\n    // 因此中央白日圓形的直徑為青天寬度的 1/4, 也就是國旗寬度的 1/8\n\n    // 而且白日十二道光芒的外圍圓形其半徑也是國旗寬度的1/8\n\n    int sun_radius = (int)(width/8);\n\n    // 中央白日圓形的直徑等於十二道光芒外圍圓形的半徑\n\n    int white_circle_dia = sun_radius;\n\n    // 中央藍色圓形半徑為中央白日的 1又 2/15\n\n    int blue_circle_dia = white_circle_dia +  white_circle_dia*2/15;\n\n    // 根據 https://www.moi.gov.tw/cp.aspx?n=10621 訂定國旗三種顏色值\n\n    red = gdImageColorAllocate(img, 255, 0, 0); // 紅色\n\n    white = gdImageColorAllocate(img, 255, 255, 255); // 白色\n\n    blue = gdImageColorAllocate(img, 0, 0, 149); // 藍色\n\n    // 根據畫布大小塗上紅色長方形區域\n\n    gdImageFilledRectangle(img, 0, 0, width, height, red);\n\n    // 青天面積為整面國旗的 1/4, 也是採用長方形塗色\n\n    gdImageFilledRectangle(img, 0, 0, (int)(width/2.0), (int)(height/2.0), blue);\n\n  {int x1 = 429;\n\n   int y1 = 125;\n\n   int x2 = 279;\n\n   int y2 = 165;\n\n\n\n   // 畫一條線連接兩個點\n\n   gdImageLine(img, x1, y1, x2, y2, white);\n\n  }\n\n  {int x1 = 170;\n\n     int y1 = 274;\n\n     int x2 = 279;\n\n     int y2 = 165;\n\n\n\n     // 畫一條線連接兩個點\n\n     gdImageLine(img, x1, y1, x2, y2, white);\n\n  }\n\n  {\n\n    int x1 = 170;\n\n     int y1 = 274;\n\n     int x2 = 429;\n\n     int y2 = 125;\n\n\n\n     // 畫一條線連接兩個點\n\n     gdImageLine(img, x1, y1, x2, y2, white);\n\n  }\n\n  // 利用一個藍色大圓與白色小圓畫出藍色環狀\n\n  gdImageFilledEllipse(img, center_x, center_y, blue_circle_dia, blue_circle_dia, blue);\n\n  gdImageFilledEllipse(img, center_x, center_y, white_circle_dia, white_circle_dia, white);\n\n\n\n\n\n  // 定義座標結構\n\n  typedef struct {\n\n      double x;\n\n      double y;\n\n  } Point;\n\n\n\n  // 計算圓與線的交點\n\n  void circleLineIntersection(double h, double k, double r, double x1, double y1, double x2, double y2) {\n\n      // 直線斜率\n\n      double m = (y2 - y1) / (x2 - x1);\n\n\n\n      // 直線方程式中的常數項\n\n      double b = y1 - m * x1;\n\n\n\n      // 圓與直線交點的計算\n\n      double A = 1 + pow(m, 2);\n\n      double B = 2 * (m * b - m * k - h);\n\n      double C = pow(k, 2) - pow(r, 2) + pow(h, 2) - 2 * b * k + pow(b, 2);\n\n\n\n      // 判斷交點個數\n\n    double discriminant = pow(B, 2) - 4 * A * C;\n\n    if (discriminant > 0) {\n\n        double x_intersect1 = (-B + sqrt(discriminant)) / (2 * A);\n\n        double y_intersect1 = m * x_intersect1 + b;\n\n        printf("交點: (%.2f, %.2f)\\n", x_intersect1, y_intersect1);\n\n\n\n        double x_intersect2 = (-B - sqrt(discriminant)) / (2 * A);\n\n        double y_intersect2 = m * x_intersect2 + b;\n\n        printf("交點: (%.2f, %.2f)\\n", x_intersect2, y_intersect2);\n\n    } else if (discriminant == 0) {\n\n        double x_intersect = -B / (2 * A);\n\n        double y_intersect = m * x_intersect + b;\n\n        printf("交點: (%.2f, %.2f)\\n", x_intersect, y_intersect);\n\n    } else {\n\n        printf("No points.\\n");\n\n    }\n\n\n\n  }\n\n\n\n\n\n      // 圓的參數\n\n      double circle_x = (int)(width/4); // 圓心 x 座標\n\n      double circle_y = (int)(height/4); // 圓心 y 座標\n\n      double radius = white_circle_dia +  white_circle_dia*2/15;   // 圓半徑\n\n\n\n      // 兩點座標\n\n\n\n\n\n\n\n  double x3 = 170;\n\n  double y3 = 274;\n\n  double x4 = 279;\n\n  double y4 = 165;\n\n\n\n  circleLineIntersection(circle_x, circle_y, radius, x4, y4, x3, y3);\n\n\n\n\n\n  double x5 = 279;\n\n  double y5 = 165;\n\n  double x6 = 429;\n\n  double y6 = 125;\n\n\n\n  circleLineIntersection(circle_x, circle_y, radius, x6, y6, x5, y5);\n}\n\n \n \n \n', 'tags': '', 'url': 'w15.html'}, {'title': 'w16', 'text': '#include <gd.h>\n#include <stdio.h>\n#include <math.h>\n\n#define WIDTH 800\n#define HEIGHT 600\n#define SCALE 100\n\nvoid drawResistor(gdImagePtr im, int x1, int y, int width, int height) {\n    int startX = x1 ;\n    int endX = x1 + width ;\n\n    // 第一段直线向前走一段\n    gdImageLine(im, startX, y, startX + width / 4 , y, gdImageColorAllocate(im, 0, 0, 255));\n\n    // 向上45度\n    gdImageLine(im, startX + width / 4 , y, startX + width / 4 + height / 2 , y - height / 2, gdImageColorAllocate(im, 0, 0, 255));\n\n    // 向下90度\n    gdImageLine(im, startX + width / 4 + height / 2, y - height / 2 , startX + width / 4 + height / 2 + height , y + height / 2, gdImageColorAllocate(im, 0, 0, 255));\n\n    // 向上90度\n    gdImageLine(im, startX + width / 4 + height / 2 + height, y + height / 2, startX + width / 4 + height / 2 + 2 * height, y - height / 2, gdImageColorAllocate(im, 0, 0, 255));\n\n    // 向下90度\n    gdImageLine(im, startX + width / 4 + height / 2 + 2 * height , y - height / 2, startX + width / 4 + height / 2 + 3 * height , y + height / 2, gdImageColorAllocate(im, 0, 0, 255));\n\n    // 向上90度\n    gdImageLine(im, startX + width / 4 + height / 2 + 3 * height, y + height / 2 , startX + width / 4 + height / 2 + 4 * height, y - height / 2, gdImageColorAllocate(im, 0, 0, 255));\n\n    // 向下90度\n    gdImageLine(im, startX + width / 4 + height / 2 + 4 * height, y - height / 2, startX + width / 4 + height / 2 + 5 * height, y + height / 2, gdImageColorAllocate(im, 0, 0, 255));\n\n  // 向上45度\n    gdImageLine(im, startX + width / 4 + height / 2 + 5 * height, y + height / 2, startX + width / 4 + height / 2 + 5 * height + height / 2, y, gdImageColorAllocate(im, 0, 0, 255));\n\n  gdImageLine(im, startX + width / 4 + height / 2 + 5 * height + height / 2, y, startX + width / 4 + height / 2 + 5 * height + height / 2 +5 , y, gdImageColorAllocate(im, 0, 0, 255));\n\n\n  {\n    int startX = 100;\n  gdImageColorAllocate(im, 0, 0, 255);\n\n\n    // 第一段直线向前走一段\n    gdImageLine(im, startX, y, startX + width / 4 , y, gdImageColorAllocate(im, 0, 0, 255));\n\n    // 向上45度\n    gdImageLine(im, startX + width / 4 , y, startX + width / 4 + height / 2 , y - height / 2, gdImageColorAllocate(im, 0, 0, 255));\n\n    // 向下90度\n    gdImageLine(im, startX + width / 4 + height / 2, y - height / 2 , startX + width / 4 + height / 2 + height , y + height / 2, gdImageColorAllocate(im, 0, 0, 255));\n\n    // 向上90度\n    gdImageLine(im, startX + width / 4 + height / 2 + height, y + height / 2, startX + width / 4 + height / 2 + 2 * height, y - height / 2, gdImageColorAllocate(im, 0, 0, 255));\n\n    // 向下90度\n    gdImageLine(im, startX + width / 4 + height / 2 + 2 * height , y - height / 2, startX + width / 4 + height / 2 + 3 * height , y + height / 2, gdImageColorAllocate(im, 0, 0, 255));\n\n    // 向上45度\n      gdImageLine(im, startX + width / 4 + height / 2 + 3 * height, y + height / 2, startX + width / 4 + height / 2 + 3 * height + height / 2, y, gdImageColorAllocate(im, 0, 0, 255));\n\n    gdImageLine(im, startX + width / 4 + height / 2 + 3 * height + height / 2, y, startX + width / 4 + height / 2 + 3 * height + height / 2 +5 , y, gdImageColorAllocate(im, 0, 0, 255));\n }\n\n  {\n    int startX = 585;\n  gdImageColorAllocate(im, 0, 0, 255);\n\n\n    // 第一段直线向前走一段\n    gdImageLine(im, startX, y, startX + width / 4 , y, gdImageColorAllocate(im, 0, 0, 255));\n\n    // 向上45度\n    gdImageLine(im, startX + width / 4 , y, startX + width / 4 + height / 2 , y - height / 2, gdImageColorAllocate(im, 0, 0, 255));\n\n  // 向下90度\n    gdImageLine(im, startX + width / 4 + height / 2, y - height / 2 , startX + width / 4 + height / 2 + height , y + height / 2, gdImageColorAllocate(im, 0, 0, 255));\n\n    // 向上90度\n    gdImageLine(im, startX + width / 4 + height / 2 + height, y + height / 2, startX + width / 4 + height / 2 + 2 * height, y - height / 2, gdImageColorAllocate(im, 0, 0, 255));\n        // 向下90度\n    gdImageLine(im, startX + width / 4 + height / 2 + 2 * height , y - height / 2, startX + width / 4 + height / 2 + 3 * height , y + height / 2, gdImageColorAllocate(im, 0, 0, 255));\n\n    // 向上45度\n      gdImageLine(im, startX + width / 4 + height / 2 + 3 * height, y + height / 2, startX + width / 4 + height / 2 + 3 * height + height / 2, y, gdImageColorAllocate(im, 0, 0, 255));\n\n    gdImageLine(im, startX + width / 4 + height / 2 + 3 * height + height / 2, y, startX + width / 4 + height / 2 + 3 * height + height / 2 +5 , y, gdImageColorAllocate(im, 0, 0, 255));\n\n    gdImageLine(im, 100, y +20, 700, y +20, gdImageColorAllocate(im, 0, 255, 0));\n\n}\n}\n\nint main() {\n    gdImagePtr im;\n    FILE *outputFile;\n\n    // 创建图像对象\n    im = gdImageCreateTrueColor(WIDTH, HEIGHT);\n    if (im == NULL) {\n        fprintf(stderr, "Error creating GD image.\\n");\n        return 1;\n    }\n\n    outputFile = fopen("1.png", "wb");\n    if (outputFile == NULL) {\n        fprintf(stderr, "Error opening the output file.\\n");\n        return 1;\n    }\n\n    int black, white, red, blue, green;\n\n    black = gdImageColorAllocate(im, 0, 0, 0);\n    white = gdImageColorAllocate(im, 255, 255, 255);\n    red = gdImageColorAllocate(im, 255, 0, 0);\n    blue = gdImageColorAllocate(im, 0, 0, 255);\ngreen = gdImageColorAllocate(im, 0, 255, 0);\n    gdImageFilledRectangle(im, 0, 0, WIDTH - 1, HEIGHT - 1, white);\n\n    // 绘制墙面\n    gdImageLine(im, SCALE, SCALE, SCALE, HEIGHT - SCALE, black);\n    gdImageLine(im, WIDTH - SCALE, SCALE, WIDTH - SCALE, HEIGHT - SCALE, black);\n\n// 绘制彈簧\n    drawResistor(im, WIDTH / 3 + SCALE / 2, HEIGHT / 2, SCALE / 2, SCALE / 4);\n\n    // 绘制质量（方形）\n    gdImageFilledRectangle(im, WIDTH / 3 - SCALE / 2, HEIGHT / 2 - SCALE / 2, WIDTH / 3 + SCALE / 2, HEIGHT / 2 + SCALE / 2, red);\n    gdImageFilledRectangle(im, WIDTH * 2 / 3 - SCALE / 2, HEIGHT / 2 - SCALE / 2, WIDTH * 2 / 3 + SCALE / 2, HEIGHT / 2 + SCALE / 2, red);\n\n  gdImageFilledRectangle(im, 100, HEIGHT +300, 700, HEIGHT /2 +49 , black);\n\n\n\n    gdImagePng(im, outputFile);\n    fclose(outputFile);\n    gdImageDestroy(im);\n\n    return 0;\n} \n \n #include <stdio.h>\n\nint main() {\n    FILE *gnuplotPipe = popen("gnuplot", "w");\n    if (gnuplotPipe) {\n        fprintf(gnuplotPipe, "set terminal png\\n");\n        fprintf(gnuplotPipe, "set output \'motion_plot.png\'\\n");\n        fprintf(gnuplotPipe, "set xlabel \'Time\'\\n");\n        fprintf(gnuplotPipe, "set ylabel \'Position / Velocity\'\\n");\n        fprintf(gnuplotPipe, "plot \'motion_data.txt\' using 1:2 with lines title \'m1 position\', \'motion_data.txt\' using 1:3 with lines title \'m2 position\', \'motion_data.txt\' using 1:4 with lines title \'m1 velocity\', \'motion_data.txt\' using 1:5 with lines title \'m2 velocity\'\\n");\n        fprintf(gnuplotPipe, "exit\\n");\n        fflush(gnuplotPipe);\n        pclose(gnuplotPipe);\n    } else {\n        printf("Error opening pipe to Gnuplot.\\n");\n    }\n    return 0;\n} \n \n \n', 'tags': '', 'url': 'w16.html'}, {'title': 'ANSIC', 'text': '1. \n #include <stdio.h>\n\nint main() \n{\n    // 声明并初始化字符变量\n    char char1 = \'X\';\n    char char2 = \'M\';\n    char char3 = \'L\';\n\n    // 打印原始和反转字符\n    printf("The reverse of %c%c%c is %c%c%c\\n",\n        char1, char2, char3,\n        char3, char2, char1);\n\n    return(0);\n} \n \n \n 2. \n #include <stdio.h>\n\nint main() {\n    int j, numbers[5], total=0; // 声明循环计数器、一个包含五个数字的数组以及总和变量\n\n    // 提示用户输入五个数字，并将它们存储在数组中\n    printf("\\n輸入第一個數字："); \n    scanf("%d", &numbers[0]);\n    printf("\\n輸入第二個數字："); \n    scanf("%d", &numbers[1]);\n    printf("\\n輸入第三個數字："); \n    scanf("%d", &numbers[2]);\n    printf("\\n輸入第四個數字："); \n    scanf("%d", &numbers[3]);\n    printf("\\n輸入第五個數字："); \n    scanf("%d", &numbers[4]);\n\n    // 通过循环遍历这些数字，找到并计算奇数的总和\n    for(j = 0; j < 5; j++) {\n        if((numbers[j] % 2) != 0) \n        {\n            total += numbers[j];\n        }   \n    }\n\n    // 打印奇數總和\n    printf("\\n所有奇數的總和：%d", total);\n    printf("\\n");\n\n    return 0;\n}\n \n \n \n \n \n 3. \n #include <stdio.h>\n\nint main() {\n    float x, y, z, P; // 声明變量以存儲三角形的三邊長和周長\n\n    // 提示用戶輸入三個數字，分別存儲在 \'x\'、\'y\' 和 \'z\'\n    printf("\\n輸入第一個數字："); \n    scanf("%f", &x);\n    printf("\\n輸入第二個數字：");\n    scanf("%f", &y);\n    printf("\\n輸入第三個數字：");\n    scanf("%f", &z);\n\n    if (x < (y + z) && y < (x + z) && z < (x + y)) // 檢查這三個數字是否能構成一個三角形\n    {  \n        P = x + y + z; // 計算周長\n        printf("\\n周長 = %.1f\\n", P); // 輸出周長\t \n    }\n    else\n    {\n        printf("無法構成三角形..！"); // 如果無法構成三角形，輸出相應的消息\n    }\n\n    return 0;\n}\n\n \n \n \n 4. \n #include <stdio.h>\n\nint main()\n{\n    // 宣告變數和指標\n    int fno, sno, *ptr, *qtr, sum;\n\n    // 提示用戶輸入第一個數字\n    printf("\\n\\n Pointer : Add two numbers :\\n");\n    printf("--------------------------------\\n");\n\n    printf(" 輸入第一個數字 : ");\n    scanf("%d", &fno);\n\n    // 提示用戶輸入第二個數字\n    printf(" 輸入第二個數字 : ");\n    scanf("%d", &sno);\n\n    // 指向第一個數字的指標\n    ptr = &fno;\n\n    // 指向第二個數字的指標\n    qtr = &sno;\n\n    // 計算兩數的總和\n    sum = *ptr + *qtr;\n\n    // 輸出總和\n    printf(" 輸入的兩個數字的總和 : %d\\n\\n", sum);\n\n    return 0;\n} \n \n 5. \n #include <stdio.h>\n\n// 函數原型\nint calculateLength(char*);\n\nvoid main() \n{\n    char str1[25];\n    int l;\n\n    printf("\\n\\n 指針：計算字符串的長度：\\n"); \n    printf("---------------------------------------------------\\n");\n\n    // 輸入一個字符串\n    printf(" 輸入一個字符串：");\n    fgets(str1, sizeof str1, stdin);\n\n    // 計算字符串的長度\n    l = calculateLength(str1);\n\n    // 輸出字符串的長度\n    printf(" 給定字符串 %s 的長度是：%d ", str1, l - 1);\n    printf("\\n\\n");\n}\n\n// 函數，用於計算字符串的長度\nint calculateLength(char* ch)\n{\n    int ctr = 0;\n\n    // 通過迭代字符直到遇到空字符\n    while (*ch != \'\\0\') \n    {\n        ctr++;\n        ch++;\n    }\n\n    return ctr;\n}\n \n \n \n 6. \n # include <stdio.h>\n# include <string.h>\n\nint main()\n{\n    int n, x = 0;\n    \n    printf("\\n\\n 檢查給定數字是否是醜數:\\n");\n    printf("----------------------------------------------------\\n");\n    \n    // 輸入一個整數\n    printf(" 輸入一個整數: ");\n    scanf("%d", &n);\n\n    if (n <= 0) \n    {  \n        printf("請輸入正確的數字.");  \n    }\n    \n    while (n != 1) \n    {  \n        if (n % 5 == 0) \n        {  \n            n /= 5;  \n        } \n        else if (n % 3 == 0) \n        {  \n            n /= 3;  \n        } \n        else if (n % 2 == 0) \n        {  \n            n /= 2;  \n        } \n        else \n        {  \n            printf("它不是一個醜數.\\n"); \n            x = 1;  \n            break;  \n        }  \n    } \n    \n    if (x == 0) \n    { \n        printf("它是一個醜數.\\n");\n    }\n\n    return 0; // 返回 0，表示正常結束程序\n}\n \n \n \n 7. \n #include <stdio.h>  // 包含標準輸入/輸出頭文件。\n\nvoid main()\n{\n    int num1, rem1;  // 声明两个整数变量 \'num1\' 和 \'rem1\'。\n\n    printf("輸入一個整數: ");  // 提示用戶輸入一個整數。\n    scanf("%d", &num1);  // 讀取並將用戶輸入的值存儲在 \'num1\' 中。\n    rem1 = num1 % 2;  // 計算 \'num1\' 除以 2 的餘數。\n    if (rem1 == 0)  // 檢查餘數是否等於 0。\n        printf("%d 是一個偶數\\n", num1);  // 打印一條消息，指示 \'num1\' 是一個偶數。\n    else\n        printf("%d 是一個奇數\\n", num1);  // 打印一條消息，指示 \'num1\' 是一個奇數。\n}\n \n \n \n 8. \n #include <stdio.h>  // 包含標準輸入/輸出頭文件。\n\nvoid main()\n{\n    int co1, co2;  // 声明两个整数变量 \'co1\' 和 \'co2\' 來存儲座標。\n\n    printf("輸入X和Y坐標的值：");  // 提示用戶輸入座標。\n    scanf("%d %d", &co1, &co2);  // 讀取並將用戶輸入的值存儲在 \'co1\' 和 \'co2\' 中。\n\n    if (co1 > 0 && co2 > 0)  // 檢查 \'co1\' 和 \'co2\' 是否都是正數。\n        printf("該座標點（%d,%d）位於第一象限。\\n", co1, co2);  // 打印一條消息，指示該座標位於第一象限。\n    else if (co1 < 0 && co2 > 0)  // 檢查 \'co1\' 是否為負數並且 \'co2\' 是否為正數。\n        printf("該座標點（%d,%d）位於第二象限。\\n", co1, co2);  // 打印一條消息，指示該座標位於第二象限。\n    else if (co1 < 0 && co2 < 0)  // 檢查 \'co1\' 和 \'co2\' 是否都是負數。\n        printf("該座標點（%d, %d）位於第三象限。\\n", co1, co2);  // 打印一條消息，指示該座標位於第三象限。\n    else if (co1 > 0 && co2 < 0)  // 檢查 \'co1\' 是否為正數並且 \'co2\' 是否為負數。\n        printf("該座標點（%d,%d）位於第四象限。\\n", co1, co2);  // 打印一條消息，指示該座標位於第四象限。\n    else if (co1 == 0 && co2 == 0)  // 檢查 \'co1\' 和 \'co2\' 是否都是零。\n        printf("該座標點（%d,%d）位於原點。\\n", co1, co2);  // 打印一條消息，指示該座標位於原點。\n}\n \n \n 9. \n #include <stdio.h>    // 包含標準輸入/輸出頭文件。\n#include <stdlib.h>   // 包含標準庫頭文件。\n#include <time.h>     // 包含時間頭文件，用於生成隨機數。\n\nint main()           // 主函數的開始。\n{\n    int number, input;   // 声明兩個整數變量 \'number\' 和 \'input\'。\n\n    srand(time(NULL));   // 使用當前時間初始化隨機種子。\n\n    number = rand() % 10 + 1;   // 生成一個介於1到10之間的隨機數並將其存儲在 \'number\' 中。\n\n    do {   // 開始一個 do-while 循環。\n        printf("\\n猜數字 (1 到 10): ");   // 打印一條消息，提示用戶猜數字。\n        scanf("%d", &input);    // 讀取用戶的輸入並將其存儲在 \'input\' 中。\n\n        if (number > input)   // 如果隨機數大於用戶的輸入。\n            printf("數字較大\\n");   // 打印一條消息，指示數字較大。\n\n    } while (number != input);   // 只要用戶的輸入不等於隨機數，就繼續循環。\n\n    printf("答對了！\\n\\n");   // 打印一條消息，指示用戶猜對了。\n\n    return 0;   // 返回 0，表示程序運行成功。\n}   // 主函數的結尾。\n \n \n 10. \n #include <time.h>    // 包含時間頭文件。\n#include <stdio.h>   // 包含標準輸入/輸出頭文件。\n#include <stdlib.h>  // 包含標準庫頭文件。\n\nint main(void)\n{\n    time_t cur_time;      // 声明一個 time_t 類型的變量 \'cur_time\' 用於存儲當前時間。\n    char* cur_t_string;   // 声明一個字符指針 \'cur_t_string\' 用於存儲轉換後的時間字符串。\n\n    cur_time = time(NULL);   // 獲取當前的日期和時間。\n    if (cur_time == ((time_t)-1))\n    {\n        (void) fprintf(stderr, "無法獲取當前日期和時間。\\n");\n        exit(EXIT_FAILURE);   // 如果獲取失敗，輸出錯誤消息並退出程序。\n    }\n\n    cur_t_string = ctime(&cur_time);   // 將時間轉換為本地時間格式的字符串。\n    if (cur_t_string == NULL)\n    {\n        (void) fprintf(stderr, "無法轉換當前日期和時間。\\n");\n        exit(EXIT_FAILURE);   // 如果轉換失敗，輸出錯誤消息並退出程序。\n    }\n\n    (void) printf("\\n 當前時間是：%s \\n", cur_t_string);   // 打印當前的日期和時間字符串。\n\n    exit(EXIT_SUCCESS);   // 退出程序，表示成功執行。\n}\n \n \n 11. \n #include <stdio.h>\n#include <stdlib.h>\n\nvoid main()\n{\n    int fno, sno, *ptr1 = &fno, *ptr2 = &sno;\n\n    printf("\\n\\n 指針：找出兩個數字之間的最大值：\\n");\n    printf("------------------------------------------------------------\\n");\n\n    printf(" 輸入第一個數字：");\n    scanf("%d", ptr1);\n    printf(" 輸入第二個數字：");\n    scanf("%d", ptr2);\n\n    if (*ptr1 > *ptr2)\n    {\n        printf("\\n\\n %d 是最大的數字。\\n\\n", *ptr1);\n    }\n    else\n    {\n        printf("\\n\\n %d 是最大的數字。\\n\\n", *ptr2);\n    }\n}\n \n \n 12. \n #define __STDC_WANT_LIB_EXT1__ 1\n#include <stdio.h>\n#include <time.h>\n\nint main(void)\n{\n    time_t t = time(NULL);  // 獲取當前時間的秒數，存儲在變數 \'t\' 中。\n\n    printf("\\n 表達為協調世界時的日曆時間是：");\n    printf("\\n UTC:   %s", asctime(gmtime(&t)));  // 使用 \'gmtime\' 將時間轉換為 UTC 時間，然後使用 \'asctime\' 打印。\n\n    printf(" 本地時間: %s\\n", asctime(localtime(&t)));  // 使用 \'localtime\' 將時間轉換為本地時間，然後使用 \'asctime\' 打印。\n\n#ifdef __STDC_LIB_EXT1__\n    struct tm buf;\n    char str[26];\n\n    asctime_s(str, sizeof str, gmtime_s(&t, &buf));  // 安全版本：使用 \'gmtime_s\' 將時間轉換為 UTC 時間，然後使用 \'asctime_s\' 打印。\n    printf(" UTC:   %s", str);\n\n    asctime_s(str, sizeof str, localtime_s(&t, &buf));  // 安全版本：使用 \'localtime_s\' 將時間轉換為本地時間，然後使用 \'asctime_s\' 打印。\n    printf(" 本地時間: %s", str);\n#endif\n}\n \n \n 13. \n #define __STDC_WANT_LIB_EXT1__ 1\n#include <stdio.h>\n#include <time.h>\n\nint main(void)\n{\n    time_t t = time(NULL);  // 獲取當前時間的秒數，存儲在變數 \'t\' 中。\n\n    printf("\\n 表達為協調世界時的日曆時間是：");\n    printf("\\n UTC:   %s", asctime(gmtime(&t)));  // 使用 \'gmtime\' 將時間轉換為 UTC 時間，然後使用 \'asctime\' 打印。\n\n    printf(" 本地時間: %s\\n", asctime(localtime(&t)));  // 使用 \'localtime\' 將時間轉換為本地時間，然後使用 \'asctime\' 打印。\n\n#ifdef __STDC_LIB_EXT1__\n    struct tm buf;\n    char str[26];\n\n    asctime_s(str, sizeof str, gmtime_s(&t, &buf));  // 安全版本：使用 \'gmtime_s\' 將時間轉換為 UTC 時間，然後使用 \'asctime_s\' 打印。\n    printf(" UTC:   %s", str);\n\n    asctime_s(str, sizeof str, localtime_s(&t, &buf));  // 安全版本：使用 \'localtime_s\' 將時間轉換為本地時間，然後使用 \'asctime_s\' 打印。\n    printf(" 本地時間: %s", str);\n#endif\n}\n \n \n 14. \n #include <stdio.h>\n\nint main() {\n    float numbers[5]; // 声明一個數組來存儲5個數字\n    int j, pctr = 0, nctr = 0; // 声明循环计数器、正數計數和負數計數\n\n    // 提示用戶輸入五個數字，並將它們存儲在數組中\n    printf("\\n輸入第一個數字："); \n    scanf("%f", &numbers[0]);\n    printf("\\n輸入第二個數字："); \n    scanf("%f", &numbers[1]);\n    printf("\\n輸入第三個數字："); \n    scanf("%f", &numbers[2]);\n    printf("\\n輸入第四個數字："); \n    scanf("%f", &numbers[3]);\n    printf("\\n輸入第五個數字："); \n    scanf("%f", &numbers[4]);\n\n    for (j = 0; j < 5; j++) {\n        if (numbers[j] > 0) // 檢查數字是否為正數\n        {\n            pctr++; // 增加正數計數\n        } else if (numbers[j] < 0) // 檢查數字是否為負數\n        {\n            nctr++; // 增加負數計數\n        }\n    }\n\n    // 輸出正數和負數的個數\n    printf("\\n正數的個數：%d", pctr);\n    printf("\\n負數的個數：%d", nctr);\n    printf("\\n");\n\n    return 0;\n}\n \n \n \n 15. \n #include <stdio.h>\n\nvoid process(int arr[], int size, int (*callback)(int))\n{\n    for (int i = 0; i < size; i++)\n    {\n        arr[i] = callback(arr[i]);\n    }\n}\nint square(int n)\n{\n    return n * n;\n}\n\nint main()\n{\n    int arr[] = {1, 2, 3, 4, 5, 6};\n    int size = sizeof(arr) / sizeof(arr[0]);\n    printf("Array elements before processing: ");\n    for (int i = 0; i < size; i++)\n    {\n        printf("%d ", arr[i]);\n    }\n    printf("\\n");\n    process(arr, size, square);\n    printf("Square of the array elements after processing: ");\n    for (int i = 0; i < size; i++)\n    {\n        printf("%d ", arr[i]);\n    }\n    printf("\\n");\n    return 0;\n} \n \n 16. \n #include <stdio.h>\n#include <stdlib.h>\n\ntypedef int( * compare_func_t)(const void * ,\n  const void * );\nvoid sort_array(int * arr, size_t n, compare_func_t compare) {\n  qsort(arr, n, sizeof(int), compare);\n}\nint ascending_order(const void * a,\n  const void * b) {\n  const int * ia = (const int * ) a;\n  const int * ib = (const int * ) b;\n  return ( * ia > * ib) - ( * ia < * ib);\n}\n\nint descending_order(const void * a,\n  const void * b) {\n  const int * ia = (const int * ) a;\n  const int * ib = (const int * ) b;\n  return ( * ib > * ia) - ( * ib < * ia);\n}\nint main() {\n  int arr[] = {\n    7,\n    2,\n    0,\n    5,\n    8,\n    9\n  };\n  size_t n = sizeof(arr) / sizeof(int);\n  printf("Original array: ");\n  for (size_t i = 0; i < n; i++) {\n    printf("%d ", arr[i]);\n  }\n  printf("\\n");\n  sort_array(arr, n, ascending_order);\n  printf("\\nAscending order: ");\n  for (size_t i = 0; i < n; i++) {\n    printf("%d ", arr[i]);\n  }\n  printf("\\n");\n  sort_array(arr, n, descending_order);\n  printf("\\nDescending order: ");\n  for (size_t i = 0; i < n; i++) {\n    printf("%d ", arr[i]);\n  }\n  printf("\\n");\n  return 0;\n} \n \n 17. \n #include <stdio.h>\n#include <stdlib.h>\n\ntypedef int( * operation_func_t)(int, int);\nint calculate(int * arr, size_t n, int initial_value, operation_func_t operation) {\n  int result = initial_value;\n  for (size_t i = 0; i < n; i++) {\n    result = operation(result, arr[i]);\n  }\n  return result;\n}\n\nint sum(int a, int b) {\n  return a + b;\n}\n\nint product(int a, int b) {\n  return a * b;\n}\nint main() {\n  int arr[] = {\n    10,\n    20,\n    30,\n    40,\n    50,\n    60\n  };\n  size_t n = sizeof(arr) / sizeof(int);\n  printf("Original array elements: ");\n  for (size_t i = 0; i < n; i++) {\n    printf("%d ", arr[i]);\n  }\n  int sum_result = calculate(arr, n, 0, sum);\n  printf("\\nSum: %d", sum_result);\n  int product_result = calculate(arr, n, 1, product);\n  printf("\\nProduct: %d", product_result);\n\n  return 0;\n} \n \n 18. \n #include <stdio.h>\n\n#include <ctype.h>\n\n\nvoid modify_string(char * str, int( * modifier)(int)) {\n  while ( * str != \'\\0\') {\n    * str = modifier( * str);\n    str++;\n  }\n}\n\nint main() {\n  char str[100];\n  printf("Input a string: ");\n  fgets(str, sizeof(str), stdin);\n\n  printf("Select an option:\\n");\n  printf("1. Convert to uppercase\\n");\n  printf("2. Convert to lowercase\\n");\n  int option;\n  scanf("%d", & option);\n\n  switch (option) {\n  case 1:\n    modify_string(str, toupper);\n    printf("Uppercase string: %s", str);\n    break;\n  case 2:\n    modify_string(str, tolower);\n    printf("Lowercase string: %s", str);\n    break;\n  default:\n    printf("Invalid option");\n    break;\n  }\n\n  return 0;\n}\n\n \n \n 19. \n #include <stdio.h>\n\n#include <stdlib.h>\n // Function to calculate the average of an array\ndouble calculate_average(int arr[], int n) {\n  int sum = 0;\n  for (int i = 0; i < n; i++) {\n    sum += arr[i];\n  }\n  return (double) sum / n;\n}\n// Comparison function for sorting the array\nint compare_ints(const void * a,\n  const void * b) {\n  int int_a = * ((int * ) a);\n  int int_b = * ((int * ) b);\n  return int_a - int_b;\n}\n\n// Function to calculate the median of an array\ndouble calculate_median(int arr[], int n) {\n  // Sort the array in ascending order\n  qsort(arr, n, sizeof(int), compare_ints);\n\n  // Calculate the median\n  double median;\n  if (n % 2 == 0) {\n    median = (double)(arr[n / 2] + arr[n / 2 - 1]) / 2;\n  } else {\n    median = arr[n / 2];\n  }\n  return median;\n}\n\n// Function to calculate the average or median of an array\ndouble calculate(int arr[], int n, double( * operation)(int arr[], int n)) {\n  return operation(arr, n);\n}\nint main() {\n  int arr[11] = {\n    2,\n    5,\n    4,\n    7,\n    1,\n    8,\n    4,\n    6,\n    5,\n    9,\n    10\n  };\n  int n = sizeof(arr) / sizeof(arr[0]);\n  printf("Original array elements: ");\n  for (size_t i = 0; i < n; i++) {\n    printf("%d ", arr[i]);\n  }\n  printf("\\n");\n  printf("\\nSelect an option:\\n");\n  printf("1. Calculate average of the said array elements:\\n");\n  printf("2. Calculate median of the said array elements:\\n");\n  int option;\n  scanf("%d", & option);\n  double result;\n  switch (option) {\n  case 1:\n    result = calculate(arr, n, calculate_average);\n    printf("Average: %f", result);\n    break;\n  case 2:\n    result = calculate(arr, n, calculate_median);\n    printf("Median: %f", result);\n    break;\n  default:\n    printf("Invalid option");\n    break;\n  }\n\n  return 0;\n}\n \n \n \n 20. \n #include <stdio.h>\n#include <gd.h>\n#include <math.h>\n\n#define WIDTH 900\n#define HEIGHT 600\n#define FILENAME "south_korea_flag.png"\n\nint main() {\n    gdImagePtr im;\n    FILE *pngout;\n    int white, black, red, blue;\n\n    im = gdImageCreate(WIDTH, HEIGHT);\n\n    white = gdImageColorAllocate(im, 255, 255, 255);\n    black = gdImageColorAllocate(im, 0, 0, 0);\n    red = gdImageColorAllocate(im, 205, 0, 0);\n    blue = gdImageColorAllocate(im, 0, 56, 168);\n\n    // Background (white)\n    gdImageFilledRectangle(im, 0, 0, WIDTH, HEIGHT , white);\n\n    // Blue Circle (Yin-Yang Symbol)\n    gdImageFilledArc(im, WIDTH / 2, HEIGHT / 2, WIDTH / 3, HEIGHT / 2, 210, 30, red, gdArc);\n\n    // Red Circle (Yin-Yang Symbol)\n    gdImageFilledArc(im, WIDTH / 2, HEIGHT / 2, WIDTH / 3, HEIGHT / 2, 30, 210, blue, gdArc);\n\n  int circleX = 385;    // 圓心的 X 座標\n  int circleY = 262.5;   // 圓心的 Y 座標\n  int circleRadius = 75;     \n\n  // 繪製圓形\n  gdImageFilledEllipse(im, circleX, circleY, circleRadius * 2, circleRadius * 2, red);\n\n  int circleX2 = 515;    // 圓心的 X 座標\n\n int circleY2 = 337.5;\n\n  // 繪製圓形\n  gdImageFilledEllipse(im, circleX2, circleY2, circleRadius * 2, circleRadius * 2, blue);\n\n  {\n\n\n  // 起點和終點位置\n\n  int startX = 340;    \n  // 線的起點 X 座標\n\n  int startY = 90;   \n  // 線的起點 Y 座標\n\n  int endX = 200;     \n  // 線的終點 X 座標\n\n  int endY = 260;     \n  // 線的終點 Y 座標\n\n  int lineWidth = 23;  // 線的寬度\n\n  // 繪製線段\n  gdImageSetThickness(im, lineWidth);\n  gdImageLine(im, startX, startY, endX, endY, black);\n  // 繪製線段\n  gdImageSetThickness(im, lineWidth);\n  gdImageLine(im, startX -35, startY -10, endX -35, endY -10, black);\n\n  // 繪製線段\n  gdImageSetThickness(im, lineWidth);\n  gdImageLine(im, startX -70, startY -20, endX -70, endY -20, black);\n\n  int startX2 = 213;    \n  // 線的起點 X 座標\n\n  int startY2 = 270;   \n  // 線的起點 Y 座標\n\n  int endX2 = 133;     \n  // 線的終點 X 座標\n\n  int endY2 = 210;     \n  // 線的終點 Y 座標\n\n  int lineWidth2 = 25;  // 線的寬度\n\n  // 繪製線段\n  gdImageSetThickness(im, lineWidth);\n  gdImageLine(im, startX2 +3, startY2, endX2 +3, endY2, white);\n\n  gdImageSetThickness(im, lineWidth +10);\ngdImageLine(im, startX2 -17, startY2 +9 , endX2 -17, endY2 +9 , white);\n\n  gdImageSetThickness(im, lineWidth );\ngdImageLine(im, startX2 +115, startY2 -145, endX2 +115, endY2 -145, white);\n\n  gdImageSetThickness(im, lineWidth);\ngdImageLine(im, startX2 +120, startY2 -155, endX2 +120, endY2 -155, white);\n\n  gdImageSetThickness(im, lineWidth +12);\ngdImageLine(im, startX2 +145, startY2 -155, endX2 +145, endY2 -155, white);\n}\n  {\n    // 起點和終點位置\n\n  int startX = 330;    \n  // 線的起點 X 座標\n\n  int startY = 520;   \n  // 線的起點 Y 座標\n\n  int endX = 190;     \n  // 線的終點 X 座標\n\n  int endY = 350;     \n  // 線的終點 Y 座標\n\n  int lineWidth = 23;  // 線的寬度\n\n  // 繪製線段\n  gdImageSetThickness(im, lineWidth);\n  gdImageLine(im, startX, startY, endX, endY, black);\n  // 繪製線段\n  gdImageSetThickness(im, lineWidth);\n  gdImageLine(im, startX -35, startY +10, endX -35, endY +10, black);\n\n  // 繪製線段\n  gdImageSetThickness(im, lineWidth);\n  gdImageLine(im, startX -70, startY +20, endX -70, endY +20, black);\n\n  int startX2 = 213;    \n  // 線的起點 X 座標\n\n  int startY2 = 330;   \n  // 線的起點 Y 座標\n\n  int endX2 = 133;     \n  // 線的終點 X 座標\n\n  int endY2 = 390;     \n  // 線的終點 Y 座標\n\n  int lineWidth2 = 25;  // 線的寬度\n\n  // 繪製線段\n  gdImageSetThickness(im, lineWidth +8);\n  gdImageLine(im, startX2 -11, startY2, endX2 -11, endY2, white);\n\n  gdImageSetThickness(im, lineWidth +10);\ngdImageLine(im, startX2 -30, startY2 -9 , endX2 -30, endY2 -9 , white);\n\n  gdImageSetThickness(im, lineWidth );\ngdImageLine(im, startX2 +100, startY2 +150, endX2 +100, endY2 +150, white);\n\n  gdImageSetThickness(im, lineWidth);\ngdImageLine(im, startX2 +120, startY2 +155, endX2 +120, endY2 +155, white);\n\n  gdImageSetThickness(im, lineWidth +14);\ngdImageLine(im, startX2 +145, startY2 +157, endX2 +145, endY2 +157, white);\n\n    gdImageSetThickness(im, lineWidth -10);\ngdImageLine(im, 232, 426, 206, 448, white);\n\n  }\n\n  {\n    // 起點和終點位置\n\n  int startX = 564;    \n  // 線的起點 X 座標\n\n  int startY = 520;   \n  // 線的起點 Y 座標\n\n  int endX = 704;     \n  // 線的終點 X 座標\n\n  int endY = 350;     \n  // 線的終點 Y 座標\n\n  int lineWidth = 23;  // 線的寬度\n\n  // 繪製線段\n  gdImageSetThickness(im, lineWidth);\n  gdImageLine(im, startX +70, startY +20, endX +70, endY +20, black);\n\n    // 繪製線段\n  gdImageSetThickness(im, lineWidth);\n  gdImageLine(im, startX, startY, endX, endY, black);\n\n    // 繪製線段\n  gdImageSetThickness(im, lineWidth);\n  gdImageLine(im, startX +35, startY +10, endX +35, endY +10, black);\n\ngdImageSetThickness(im, lineWidth -10);\ngdImageLine(im, 624, 400, 734, 490, white);\n\n  int startX2 = 553;    \n  // 線的起點 X 座標\n\n  int startY2 = 330;   \n  // 線的起點 Y 座標\n\n  int endX2 = 633;     \n  // 線的終點 X 座標\n\n  int endY2 = 390;     \n  // 線的終點 Y 座標\n\n  int lineWidth2 = 25;  // 線的寬度\n\n  // 繪製線段\n  gdImageSetThickness(im, lineWidth +8);\n  gdImageLine(im, startX2 +139, startY2, endX2 +139, endY2, white);\n\n  gdImageSetThickness(im, lineWidth +10);\ngdImageLine(im, startX2 +157, startY2 -9 , endX2 +157, endY2 -9 , white);\n\n  gdImageSetThickness(im, lineWidth);\ngdImageLine(im, startX2 +25, startY2 +155, endX2 +25, endY2 +155, white);\n\n  gdImageSetThickness(im, lineWidth +30);\ngdImageLine(im, startX2 -3, startY2 +170, endX2 , endY2 +170, white);\n  }\n  {\n    // 起點和終點位置\n\n  int startX = 330;    \n  // 線的起點 X 座標\n\n  int startY = 520;   \n  // 線的起點 Y 座標\n\n  int endX = 190;     \n  // 線的終點 X 座標\n\n  int endY = 350;     \n  // 線的終點 Y 座標\n\n  int lineWidth = 23;  // 線的寬度\n\n  // 繪製線段\n  gdImageSetThickness(im, lineWidth);\n  gdImageLine(im, startX, startY, endX, endY, black);\n  // 繪製線段\n  gdImageSetThickness(im, lineWidth);\n  gdImageLine(im, startX -35, startY +10, endX -35, endY +10, black);\n\n  // 繪製線段\n  gdImageSetThickness(im, lineWidth);\n  gdImageLine(im, startX -70, startY +20, endX -70, endY +20, black);\n\n  int startX2 = 213;    \n  // 線的起點 X 座標\n\n  int startY2 = 330;   \n  // 線的起點 Y 座標\n\n  int endX2 = 133;     \n  // 線的終點 X 座標\n\n  int endY2 = 390;     \n  // 線的終點 Y 座標\n\n  int lineWidth2 = 25;  // 線的寬度\n\n  // 繪製線段\n  gdImageSetThickness(im, lineWidth +8);\n  gdImageLine(im, startX2 -11, startY2, endX2 -11, endY2, white);\n\n  gdImageSetThickness(im, lineWidth +10);\ngdImageLine(im, startX2 -30, startY2 -9 , endX2 -30, endY2 -9 , white);\n\n  gdImageSetThickness(im, lineWidth );\ngdImageLine(im, startX2 +100, startY2 +150, endX2 +100, endY2 +150, white);\n\n  gdImageSetThickness(im, lineWidth);\ngdImageLine(im, startX2 +120, startY2 +155, endX2 +120, endY2 +155, white);\n\n  gdImageSetThickness(im, lineWidth +14);\ngdImageLine(im, startX2 +145, startY2 +157, endX2 +145, endY2 +157, white);\n\n    gdImageSetThickness(im, lineWidth -10);\ngdImageLine(im, 232, 426, 206, 448, white);\n\n  }\n  {\n    // 起點和終點位置\n\n  int startX = 564;    \n  // 線的起點 X 座標\n\n  int startY = 97;   \n  // 線的起點 Y 座標\n\n  int endX = 704;     \n  // 線的終點 X 座標\n\n  int endY = 267;     \n  // 線的終點 Y 座標\n\n  int lineWidth = 23;  // 線的寬度\n\n  // 繪製線段\n  gdImageSetThickness(im, lineWidth);\n  gdImageLine(im, startX +70, startY -20, endX +70, endY -20, black);\n\n    // 繪製線段\n  gdImageSetThickness(im, lineWidth);\n  gdImageLine(im, startX, startY, endX, endY, black);\n\n    gdImageSetThickness(im, lineWidth -10);\ngdImageLine(im, 624, 212, 734, 118, white);\n\n    // 繪製線段\n  gdImageSetThickness(im, lineWidth);\n  gdImageLine(im, startX +35, startY -10, endX +35, endY -10, black);\n\n  int startX2 = 553;    \n  // 線的起點 X 座標\n\n  int startY2 = 277;   \n  // 線的起點 Y 座標\n\n  int endX2 = 633;     \n  // 線的終點 X 座標\n\n  int endY2 = 217;     \n  // 線的終點 Y 座標\n\n  int lineWidth2 = 25;  // 線的寬度\n\n  // 繪製線段\n  gdImageSetThickness(im, lineWidth +8);\n  gdImageLine(im, startX2 +134, startY2, endX2 +134, endY2, white);\n\n  gdImageSetThickness(im, lineWidth +10);\ngdImageLine(im, startX2 +157, startY2 +9 , endX2 +157, endY2 +9 , white);\n\n  gdImageSetThickness(im, lineWidth);\ngdImageLine(im, startX2 +25, startY2 -155, endX2 +25, endY2 -155, white);\n\n    gdImageSetThickness(im, lineWidth +30);\ngdImageLine(im, startX2 -5, startY2 -155, endX2 -5, endY2 -155, white);\n\n  }\n\n    // Save image\nFILE *outputFile = fopen("./../images/korea_flag.png", "wb");\nif (outputFile == NULL) {\n    fprintf(stderr, "Error opening the output file.\\n");\n    return 1;\n}\n  gdImagePngEx(im, outputFile, 9);\n      fclose(outputFile);\n      gdImageDestroy(im);\n      return 0;\n  } \n', 'tags': '', 'url': 'ANSIC.html'}, {'title': 'c_ex', 'text': '', 'tags': '', 'url': 'c_ex.html'}, {'title': '程式練習二', 'text': '1. \n /* ====================\nLogical NOT.\n==================== */\n#include <stdio.h>\nvoid main()\n{\nint a;\na = 3;\nprintf("%d\\n", !a );\na = 0;\nprintf("%d\\n", !a );\n} \n \n \n \n 2. \n /* ====================\n基本運算範例.\n==================== */\n#include<stdio.h>\nint main()\n{\nint a,b;\na = 10; b = 3;\nprintf( "%d \\n", a * b );\nprintf( "%d \\n", a / b );\nprintf( "%d \\n", a + b );\nprintf( "%d \\n", a - b );\nprintf( "%d \\n", a % b );\nreturn 0;\n} \n \n \n \n 3. \n /* ====================\n關係運算元的範例.\n==================== */\n#include <stdio.h>\nint main()\n{\nint a = 10, b = 5;\nprintf( " a == b is %d \\n", a == b );\nprintf( " a > b is %d \\n", a > b );\nprintf( " a < b is %d \\n", a < b );\nprintf( " a >= b is %d \\n", a >= b );\nprintf( " a <= b is %d \\n", a <= b );\nprintf( " a != b is %d \\n", a != b );\nprintf( "\\n" );\nb = 10;\nprintf( " a == b is %d \\n", a == b );\nprintf( " a > b is %d \\n", a > b );\nprintf( " a < b is %d \\n", a < b );\nprintf( " a >= b is %d \\n", a >= b );\nprintf( " a <= b is %d \\n", a <= b );\nprintf( " a != b is %d \\n", a != b );\nreturn 0;\n} \n \n \n \n \n 4. \n /* ====================\n位元運算元的範例.\n==================== */\n#include<stdio.h>\nvoid main()\n{\nint a,b;\na = 15;\nb = 1;\nprintf("%d \\n", a | b ); /* a OR b */\nprintf("%d \\n", a & b ); /* a AND b */\nprintf("%d \\n", a ^ b ); /* a XOR b */\nprintf("%d \\n", a << 1 ); /* a 位元左移 1 位 */\nprintf("%d \\n", a >> 1 ); /* a 位元右移一位 */\nprintf("%d \\n", ~a ); /* A 的補數運算 */\n} \n \n \n \n 5. \n /* ====================\nsizeof 的範例.\n==================== */\n#include <stdio.h>\nvoid main()\n{\nchar a;\nprintf( " The size of int is %d \\n", sizeof(int) );\nprintf( " The size of char a is %d \\n", sizeof(a) );\n} \n \n \n \n \n 6. \n /* ====================\n Program 5 - for\n ==================== */\n#include <stdio.h>\nvoid main()\n{\nint i, j;\ni = 0; j = 10; /* 迴圈外先設定初值 */\nfor ( ; i < 6; )\n{\nprintf( "i = %d, ", i );\nprintf( "j = %d \\n", j );\ni++;\nj++;\n}\n}\n \n \n \n \n 7. \n /* ====================\nswitch - case 的範例 1.\n==================== */\n#include <stdio.h>\nvoid main()\n{\nchar c ;\nprintf( "Input a char:" );\nscanf( "%c", &c );\nswitch( c )\n{\ncase \'a\':\nprintf(" you pressed a ");\nbreak;\ncase \'b\':\nprintf(" you pressed b ");\nbreak;\ncase \'c\':\nprintf(" you pressed c ");\nbreak;\ndefault:\nprintf(" not a, b, c ");\nbreak;\n}\n} \n \n \n \n 8. \n /* ====================\nProgram "continue"\n==================== */\n#include <stdio.h>\nvoid main()\n{\nint i;\nfor( i = 0; i < 10; i++ )\n{\nif( (i != 5) || (i != 6) || (i != 8) )\n{\ncontinue; /* 忽略以後的 program, 回到 for. */\n}\nprintf( "i = %d\\n ", i );\n}\n} \n \n \n 9. \n #include <stdio.h>\n\nint main()\n{\n    int x, y;\n\n    for (x = 1; x <= 9; x++)\n    {\n        for (y = 1; y <= 9; y++)\n        {\n            printf("%d ", x * y);\n        }\n        printf("\\n");\n    }\n\n    return 0;\n} \n \n \n \n \n 10. \n #include <stdio.h>\n\nvoid main()\n{\n    int i, j;\n    i = 0;\n    j = 10; /* 在迴圈外先設定初值 */\n\n    // 使用 while 迴圈，當 i 小於 6 時執行迴圈內部的程式碼\n    while (i < 6)\n    {\n        printf("i = %d, ", i);\n        printf("j = %d \\n", j);\n\n        // i 和 j 分別遞增\n        i++;\n        j++;\n    }\n} \n \n \n \n \n', 'tags': '', 'url': '程式練習二.html'}, {'title': 'W2~W5 Exercises', 'text': '1. \n #include <stdio.h>\n\nvoid main()\n{\n    int i, j;\n    i = 0;\n    j = 10; /* 在迴圈外先設定初值 */\n\n    // 使用 do-while 迴圈，先執行一次循環內的程式碼\n    do\n    {\n        printf("i = %d, ", i);\n        printf("j = %d \\n", j);\n\n        // i 和 j 分別遞增\n        i++;\n        j++;\n    } while (i < 6); /* 檢查條件的地方 */\n} \n \n \n \n 2. \n #include <stdio.h>\n\nint main()\n{\n    int grade[5]; /* 大小為 5 的陣列 */\n    int i;\n\n    grade[0] = 75; /* 第一個元素 */\n    grade[1] = 80; /* 第二個元素 */\n    grade[2] = 85; /* 第三個元素 */\n    grade[3] = 70; /* 第四個元素 */\n    grade[4] = 90; /* 第五個元素 */\n\n    // 使用迴圈輸出陣列的元素\n    for (i = 0; i < 5; i++)\n    {\n        printf("Number %d = %d\\n", i, grade[i]);\n    }\n\n    return 0;\n} \n \n \n \n \n 3. \n #include <stdio.h>\n\nint main()\n{\n    int array[3][3];\n    int x, y;\n\n    // 將數值分配給二維陣列中的每個元素\n    array[0][0] = 1;\n    array[0][1] = 2;\n    array[0][2] = 3;\n    array[1][0] = 4;\n    array[1][1] = 5;\n    array[1][2] = 6;\n    array[2][0] = 7;\n    array[2][1] = 8;\n    array[2][2] = 9;\n\n    // 使用巢狀迴圈遍歷二維陣列，並輸出每個元素的值\n    for (x = 0; x < 3; x++)\n    {\n        for (y = 0; y < 3; y++)\n        {\n            printf("%d,", array[x][y]);\n        }\n    }\n\n    return 0;\n} \n \n \n \n 4. \n #include <stdio.h>\n\nint main()\n{\n    char *s_pointer = "Hello";\n    char ch1, ch2;\n\n    ch1 = *s_pointer;\n    ch2 = s_pointer[0];\n\n    printf("%c, %c", ch1, ch2);\n\n    return 0;\n}\n \n \n \n \n 5. \n #include <stdio.h>\n\nvoid main()\n{\n    char *str = "Eric";\n\n    // 透過指標運算存取字串中的各個字元並輸出\n    printf("%c", *(str + 0)); /* 也可寫 printf("%c", str[0]); */\n    printf("%c", *(str + 1)); /* 也可寫 printf("%c", str[1]); */\n    printf("%c", *(str + 2)); /* 也可寫 printf("%c", str[2]); */\n    printf("%c", *(str + 3)); /* 也可寫 printf("%c", str[3]); */\n} \n \n \n \n 6. \n #include <stdio.h>\n\nint main()\n{\n    int *pointer_a, a;\n\n    // 將指標 pointer_a 指向變數 a 的位址\n    pointer_a = &a;\n\n    // 將變數 a 賦值為 10\n    a = 10;\n\n    // 輸出變數 a 的值和指標 pointer_a 所指向的值\n    printf("%d, %d", a, *pointer_a);\n\n    return 0;\n} \n \n \n \n 7. \n #include <stdio.h>\n#include <string.h>\n\n/* 定義一個結構 Mouse */\nstruct Mouse\n{\n    int xPos, yPos;\n    char Name[10];\n};\n\n/* 主函數 */\nint main()\n{\n    /* 創建一個 Mouse 結構的實例 myMouse */\n    struct Mouse myMouse;\n\n    /* 給結構成員賦值 */\n    myMouse.xPos = 10;\n    myMouse.yPos = 20;\n    strcpy(myMouse.Name, "Micky");\n\n    /* 輸出結構成員的值 */\n    printf("Name: %s, X: %d, Y: %d", myMouse.Name, myMouse.xPos, myMouse.yPos);\n\n    return 0;\n}\n \n \n \n \n 8. \n include <stdio.h>\n\n/* 定義一個共用體 Record1 */\nunion Record1\n{\n    int xPos, yPos;\n    char ch;\n};\n\n/* 主函數 */\nint main()\n{\n    /* 創建一個 Record1 共用體的實例 R1 */\n    union Record1 R1;\n\n    /* 將 xPos 成員賦值為 66 */\n    R1.xPos = 66;\n\n    /* 由於共用體的所有成員共享同一塊記憶體，因此 yPos 和 ch 也會被賦值為 66 */\n    printf("xPos=%d, yPos=%d, ch=%c", R1.xPos, R1.yPos, R1.ch);\n\n    return 0;\n} \n \n \n \n 9. \n #include <stdio.h>\n\n/* 定義一個函數 Hello，該函數打印 "Hello" */\nvoid Hello(void)\n{\n    printf(" Hello ");\n}\n\n/* 主函數 */\nint main()\n{\n    void (*func)(void); /* 宣告一個函數指標 */\n\n    func = Hello; /* 將 Hello 函數的位址指派給 func */\n\n    func(); /* 使用函數指標呼叫 Hello 函數 */\n\n    return 0;\n}\n \n \n \n \n 10. \n #include<stdio.h>\n\n#define ONE 1\n#define TWO 2\n#define HELLO "hello"\n\nint main()\n{\n    printf("%d, %d, %s", ONE, TWO, HELLO);\n    return 0;\n} \n \n \n', 'tags': '', 'url': 'W2~W5 Exercises.html'}, {'title': 'Brython', 'text': 'https://en.wikipedia.org/wiki/Python_(programming_language) \n Examples: \n https://gist.github.com/mdecycu/d9082d678096bd58378d6afe2c7fa05d \n https://www.geeksforgeeks.org/python-programming-examples/ \n https://www.programiz.com/python-programming/examples \n https://www.freecodecamp.org/news/python-code-examples-sample-script-coding-tutorial-for-beginners/ \n Python Tutorial: \n https://docs.python.org/3/tutorial/ \n An informal introduction to Python \n Indentation (Python 採 4 個 Spaces 縮排, 以界定執行範圍) \n Variables ( Python Keywords ) \n Comments (# 單行註解, 三個單引號或三個雙引號標註多行註解) \n Numbers  (整數 int(), 浮點數 float()) \n Strings  (字串) \n print (Python 內建函式,  print()  函式) \n Python control flow tools \n for \n if \n range \n open \n read \n lists \n tuples \n dictionaries \n functions \n try ... except \n break \n pass \n classes \n 這個頁面 demo 如何在同一頁面下納入多個線上 Ace 編輯器與執行按鈕 ( practice_html.txt  動態頁面超文件). \n practice_html.txt  動態頁面超文件應該可以在啟動 Brython 時, 設定將 .py 檔案放入 downloads/py 目錄中引用. \n 亦即將所有對應的 html 也使用 Brython 產生, 然後寫為  class  後, 在範例導入時透過  instance  引用. \n <!-- 啟動 Brython -->\n<script>\nwindow.onload=function(){\nbrython({debug:1, pythonpath:[\'./../cmsimde/static/\',\'./../downloads/py/\']});\n}\n</script> \n 從 1 累加到 100: \n 1 add to 100 \n 將 iterable 與 iterator  相關說明 , 利用 Brython 與 Ace Editor 整理在這個頁面. \n  導入 brython 程式庫  \n \n \n \n \n  啟動 Brython  \n \n \n \n  導入 FileSaver 與 filereader  \n \n \n \n \n  導入 ace  \n \n \n \n \n \n \n  導入 gearUtils-0.9.js Cango 齒輪繪圖程式庫  \n \n \n \n \n \n \n  請注意, 這裡使用 Javascript 將 localStorage["kw_py_src1"] 中存在近端瀏覽器的程式碼, 由使用者決定存檔名稱 \n \n \n \n \n \n \n  add 1 to 100 開始  \n \n \n  add 1 to 100 結束 \n  editor1 開始  \n  用來顯示程式碼的 editor 區域  \n \n  以下的表單與按鈕與前面的 Javascript doSave 函式以及 FileSaver.min.js 互相配合  \n  存擋表單開始  \n Filename:  .py   \n  存擋表單結束  \n \n  執行與清除按鈕開始  \n Run   Output   清除輸出區 清除繪圖區 Reload \n  執行與清除按鈕結束  \n \n  程式執行 ouput 區  \n \n  Brython 程式執行的結果, 都以 brython_div1 作為切入位置  \n \n  editor1 結束   ##########################################  \n 從 1 累加到 100 part2: \n 1 add to 100 cango_three_gears BSnake AI Tetris Rotating Block \n  請注意, 這裡使用 Javascript 將 localStorage["kw_py_src2"] 中存在近端瀏覽器的程式碼, 由使用者決定存檔名稱 \n \n \n \n  add 1 to 100 part2 開始  \n \n \n  add 1 to 100 part2 結束 \n  editor2 開始  \n  用來顯示程式碼的 editor 區域  \n \n  以下的表單與按鈕與前面的 Javascript doSave 函式以及 FileSaver.min.js 互相配合  \n  存擋表單開始  \n Filename:  .py   \n  存擋表單結束  \n \n  執行與清除按鈕開始  \n Run   Output   清除輸出區 清除繪圖區 Reload \n  執行與清除按鈕結束  \n \n  程式執行 ouput 區  \n \n  Brython 程式執行的結果, 都以 brython_div1 作為切入位置  \n \n  editor2 結束  \n \n \n', 'tags': '', 'url': 'Brython.html'}]};